/*********************************************************************************
 * Especificación JavaCC para el lenguaje MiniLeng (Procesadores de Lenguajes)
 *
 * Fichero:    minilengcompiler.jj
 * Autor:      Fernando Peña (NIA: 756012)
 * Fecha:      29/03/2020
 * Versión:    v2.0
 * Asignatura: Procesadores de Lenguajes, curso 2019-2020
 **********************************************************************************/
options{  static = true;
  ignore_case = true;
  // debug_parser = true;
  }PARSER_BEGIN(minilengcompiler)

package analizador;

import java.util.Date;
import java.time.LocalDateTime;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;

import analizador.TokenMgrError;
import analizador.minilengcompilerTokenManager;
import analizador.SimpleCharStream;

import lib.lexico.TablaOcurrencias;
import lib.lexico.ErrorLexico;
import lib.sintactico.ErrorSintactico;

public class minilengcompiler {

  	private static final String version = "2.0";
  	private static final String fecha_version = "marzo de 2020";
  	private static final String fecha_compilado = "29-03-2020";


	private static Boolean verbose_mode = false;
	private static Boolean show_tokens = false;

	private static Boolean compilado_sin_errores = true;
  	

	private static void help() {
		System.out.println("Uso: minilengcompiler [opciones] [fichero ...]\n");
      	System.out.println("Opciones:");
      	System.out.println("  -v, --verbose  Mostrar resumen de los símbolos utilizados en el programa");
      	System.out.println("  -t, --tokens   Muestra los tokens que se van reconociendo");
      	System.out.println("  -h, --help	 Imprimir ayuda (esta pantalla) y salir");
      	System.out.println("  --version      Imprimir información de la versión y salir");
      		
      	System.exit(0);
    }

    private static void version() {
		System.out.println("  Compilador de MiniLeng Versión " + version + "    Compilado el " + fecha_compilado);
		System.out.println("");
		System.out.println("    Prácticas de la asignatura: Procesadores de Lenguajes");
		System.out.println("      Curso 2019-2020");
		System.out.println("      Universidad de Zaragoza");
		System.out.println("");
		System.out.println("  Programado con JavaCC en Eclipse 2019-12");
		System.out.println("  JavaCC Eclipse Plug-in 1.5.33");
		
      	System.exit(0);
    }
 	public static void main(String args []) throws ParseException {
		System.out.println("Compilador de MiniLeng -- v" + version + " (" + fecha_version + ")");
    	System.out.println("Autor: Fernando Peña Bes (NIA: 756012)\n");
       	minilengcompiler parser;
    	InputStream stream = System.in;


    	String ficheros_entrada[] = null;


    	if (args.length == 0) {
    	  	// Compilador llamado sin argumentos
      		// System.out.println("MiniLeng: Leyendo de la entrada estándar...");
      		// parser = new minilengcompiler(System.in);
      		// No se han introducido argumentos
    	}
    	else if (args[0].equals("-h") || args[0].equals("--help")) {
    	  	// Mostrar ayuda y salir
    	  	help();
  		}
  		else if (args[0].equals("--version")) {
    	  	// Mostrar ayuda y salir
    	  	version();
  		}
  		else {
  			// Leer los argumentos.
  			// Va leyendo hasta que encuentra uno que no empieza por '-', todos los
  			// argumentos depués de ese se consideran ficheros de entrada
  			for (int i = 0; i < args.length; i++) {
  			    switch(args[i]) {
  			        case "-h":
  			        case "--help":
  			        case "--version":
  			            // Ignorar si aparece ayuda o versión de nuevo
  			        	break;

  			        case "-t":
  			        case "--tokens":
  			        	// Mostrar tokens conforme se reconocen
  			        	show_tokens = true;
  			        	break;
  			        	
  			        	
  			      	case "-v":
  			      	case "--verbose":
  			      		// Activar modo verboso
  			      		verbose_mode = true;
  			      		break;

					default:
						if (args[i].charAt(0) == '-') {
							System.err.println("MiniLeng: Opción inválida <" + args[i] + ">\n");
							help();
						}
						else {
						  	ficheros_entrada = Arrays.copyOfRange(args, i, args.length);
						}
						break;
  			    }
  			}
 		}

		/*
	   	for (fichero : ficheros_entrada) {
  			System.out.println("MiniLeng: Leyendo el fichero " + fichero + "...");
  			try {
    			// parser = new minilengcompiler(new FileInputStream(args[0]));
    			stream = new FileInputStream(args[0]);
  			}
  			catch (FileNotFoundException e) {
    			System.out.println("MiniLeng: No he encontrado el fichero " + args[0] + ".");
  			}
		}

		if (ficheros_entrada == null) {
		  	// No se ha introducido ningún fichero
			System.out.println("MiniLeng: No se ha introducido ningún fichero\n");
		  	help();
		}
		*/

		if (ficheros_entrada != null) {
		  	// Lectura del fichero del usuario.
			String fichero = ficheros_entrada[0];
			
			// Si el fichero no terminal en .ml, error
			if (!fichero.endsWith(".ml")) {
        		System.err.println("MiniLeng: El fichero a compilar tiene que tener extensión .ml");
        		System.err.println("          Fichero introducido: " + fichero);
        		System.exit(0);
			}
			
			// Ejecutar el compilador con los fichero introducidos
			System.out.println("MiniLeng: Leyendo el fichero " + fichero + " ...");
      		try {
        		// parser = new minilengcompiler(new FileInputStream(args[0]));
        		stream = new FileInputStream(fichero);
      		}
      		catch (FileNotFoundException e) {
        		System.err.println("MiniLeng: No he encontrado el fichero " + fichero + " .");
        		System.exit(0);
      		}
		}
		else {
  			System.out.println("MiniLeng: Leyendo de la entrada estándar ...");
		}
				try {
	  		parser = new minilengcompiler(stream);			switch (minilengcompiler.programa()) {  				case 0 :   					System.out.println("OK.");  					break;  				case 1 :   					System.out.println("Adiós.");  					break;  				default :   					break;			}		}		catch (Exception e) {
			// Detectado error sintáctico			System.out.println("NOK.");			System.out.println(e.getMessage());
			// errorSintactico();		}		catch (Error e) {
		  	// Detectado error léxico
			SimpleCharStream entrada = minilengcompilerTokenManager.input_stream;
			String error;
			
			try { 
				error = Character.toString(entrada.readChar());
			}
			catch (java.io.IOException fin_fichero) {
		  		error = "<EOF>";
			}

			ErrorLexico.deteccion(entrada.getEndLine(), entrada.getEndColumn(), error, TokenMgrError.addEscapes(error));
		}

		resultadosCompilacion();  	}

	static void resultadosCompilacion() {
	  	// Mostrar contadores de errores
		if (ErrorLexico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores léxicos: " + ErrorLexico.getContadorErrores());
		}

		if (ErrorSintactico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores sintácticos: " + ErrorSintactico.getContadorErrores());
		}

		if (compilado_sin_errores) {
		  	System.out.println("No se ha podido compilar el programa");
		}
		else {
		  	System.out.println("Compilado sin errores");
		}
	}
}PARSER_END(minilengcompiler)



/**** Análisis léxico ****/

TOKEN_MGR_DECLS : {
  // Crear e inicializar tabla de ocurrencias
  static TablaOcurrencias tabla = new TablaOcurrencias(minilengcompiler.show_tokens);
}
SKIP : {  " "| "\r"| "\t"| "\n"
| < "%"~["%"] > : COMENTARIO
| "%%"          : MULTICOMENTARIO}

// Ignorar comentarios en la entrada
< COMENTARIO > SKIP : {
  "\n" : DEFAULT
}

<COMENTARIO> MORE : {
   < ~[] >
}

<MULTICOMENTARIO> SKIP : {
  "%%" : DEFAULT
}

<MULTICOMENTARIO> MORE : {
   < ~[] >
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tPROGRAMA);
  }
| < tVAR : "var" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tVAR);
  }
| < tPRINCIPIO : "principio" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tPRINCIPIO);
  }
| < tFIN : "fin" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tFIN);
  }
| < tSI : "si" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tSI);
  }
| < tENT : "ent" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tENT);

  }
| < tSI_NO : "si_no" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tSI_NO);
  }
| < tFSI : "fsi" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tFSI);
  }
| < tMQ : "mq" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tMQ);
  }
| < tFMQ : "fmq" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tFMQ);
  }
| < tESCRIBIR : "escribir" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tESCRIBIR);
  }
| < tLEER : "leer" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tLEER);
  }

  // Funciones predefinidas
| < tENTACAR : "entacar" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tENTACAR);
  }
| < tCARAENT : "caraent" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tCARAENT);
  }

  // Funciones
| < tACCION : "accion" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tACCION);
  }
| < tVAL : "val" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tVAL);
  }
|  < tREF : "ref" >
  {
    tabla.incrementar(TablaOcurrencias.Reservadas.tREF);
  }
}


TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    tabla.incrementar(TablaOcurrencias.Tipos.tENTERO);
  }
| < tBOOLEANO : "booleano" >
  {
    tabla.incrementar(TablaOcurrencias.Tipos.tBOOLEANO);
  }
| < tCARACTER : "caracter" >
  {
    tabla.incrementar(TablaOcurrencias.Tipos.tCARACTER);
  }
}


TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    tabla.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_IZQ);
  }
| < tLLAVE_DER : "}" >
  {
    tabla.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_DER);
  }
| < tPARENTESIS_IZQ : "(" >
  {
    tabla.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_IZQ);
  }
| < tPARENTESIS_DER : ")" >
  {
    tabla.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_DER);
  }
}


TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    tabla.incrementar(TablaOcurrencias.Operadores.tOPAS);
  }

| < tFIN_SENTENCIA : ";" > {
    tabla.incrementar(TablaOcurrencias.Operadores.tFIN_SENTENCIA);
  }
| < tSEP_VARIABLE : "," > {
    tabla.incrementar(TablaOcurrencias.Operadores.tSEP_VARIABLE);
  }

  // Aritméticos
| < tMAS : "+" >
  {
    tabla.incrementar(TablaOcurrencias.OpAritmeticos.tMAS);
  }
| < tMENOS : "-" >
  {
    tabla.incrementar(TablaOcurrencias.OpAritmeticos.tMENOS);
  }
| < tPRODUCTO : "*" >
  {
    tabla.incrementar(TablaOcurrencias.OpAritmeticos.tPRODUCTO);
  }
| < tDIVISION : "/" >
  {
    tabla.incrementar(TablaOcurrencias.OpAritmeticos.tDIVISION);
  }
| < tMOD : "mod" >
  {
    tabla.incrementar(TablaOcurrencias.OpAritmeticos.tMOD);
  }

  // Lógicos
| < tAND : "and" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tAND);
  }
| < tOR : "or" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tOR);
  }
| < tNOT : "not" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tNOT);
  }
| < tMAYOR : ">" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tMAYOR);
  }
| < tMENOR : "<" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tMENOR);
  }
| < tIGUAL : "=" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tIGUAL);
  }
| < tMAI : ">=" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tMAI);
  }
| < tMEI : "<=" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tMEI);
  }
| < tNI : "<>" >
  {
    tabla.incrementar(TablaOcurrencias.OpLogicos.tNI);
  }
}
  

TOKEN : /* VALORES */
{
  < #DIGITO : [ "0"-"9" ] >
| < #LETRA : [ "a"-"z" ] >

  // Booleanos
| < tTRUE : "true" >
  {
    tabla.incrementar(TablaOcurrencias.Valores.tTRUE, "True");
  }
| < tFALSE : "false" >
  {
     tabla.incrementar(TablaOcurrencias.Valores.tFALSE, "False");
  }
  
  // Identificadores
| < tIDENTIFICADOR : (< LETRA > | "_"(< LETRA > | < DIGITO >))(("_")?(< LETRA > | < DIGITO >))* >
  {
    tabla.incrementar(TablaOcurrencias.Valores.tIDENTIFICADOR, matchedToken.image);
  }

  // Enteros
  // | < tCONSTENTERA : ("+" | "-")?(["0"-"9"])+ >
| < tCONSTENTERA : (["0"-"9"])+ >
  {
    tabla.incrementar(TablaOcurrencias.Valores.tCONSTENTERA, matchedToken.image);
  }
  
   // Caracteres
| < tCONSTCHAR : "\""(~["\""])?"\"" >
  {
    tabla.incrementar(TablaOcurrencias.Valores.tCONSTCHAR, matchedToken.image);
  }
  
  // Cadena de caracteres
| < tCONSTCAD : "\""(~["\""])*"\"" >
  {
    tabla.incrementar(TablaOcurrencias.Valores.tCONSTCAD, matchedToken.image);
  }
}



/**** Análisis sintáctico ****/

// Inicio programa
int programa() :
{}
{
  try { 
  	<tPROGRAMA> identificador() fin_sentencia()
  	declaracion_variables()  declaracion_acciones()
  	bloque_sentencias() < EOF >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "La declaración del programa es incorrecta");
  }

  
  {
    if (verbose_mode) {
      token_source.tabla.imprimirTabla();
    }
    return 0;
  }
 
}

// Declaraciones de separadores y limitadores de bloque
void fin_sentencia() :
{}
{  try {
    < tFIN_SENTENCIA >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ';'");  }
}
void sep_variable() :
{}
{
  try {
    < tSEP_VARIABLE >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ','");
  }
}

void parentesis_izq() :
{}
{
  try {
    < tPARENTESIS_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta paréntesis de cierre, ')'");
  }
}
void parentesis_der() :
{}
{
  try {
    < tPARENTESIS_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '('");
  }
}

void principio() :
{}
{
  try {
    < tPRINCIPIO >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de principio de bloque, 'principio'");
  }
}
void fin() :
{}
{
  try {
    < tFIN >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador fin de bloque, 'fin'");
  }
}

void identificador() :
{}
{
  try {
    < tIDENTIFICADOR >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un identificador");
  }
}



void declaracion_variables() :
{}
{
  try {
  	( declaracion() fin_sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
void declaracion() :
{}
{
  try {
  	tipo_variables()  identificadores()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de variables");
  }
}
void tipo_variables() :
{}
{
  try {
  	<tENTERO> | <tCARACTER> | <tBOOLEANO>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Tipo de dato desconocido, se esperaba: 'entero', 'caractero' o 'booleano'");
  }
}
void identificadores() :
{}
{
  try {
  	identificador() ( sep_variable() identificador() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba uno o varios identificadores");
  }
}


void declaracion_acciones() :
{}
{
  try { 
  	( declaracion_accion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
void declaracion_accion() :
{}
{
  try { 
  	cabecera_accion() fin_sentencia()
  	declaracion_variables()  declaracion_acciones()  bloque_sentencias()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de acción");
  }
}
void cabecera_accion() :
{}
{
  try {
  <tACCION> identificador() parametros_formales()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta la cabecera de la acción");
  }
}

void parametros_formales() :
{}
{
  try { 
	( parentesis_izq() ( lista_parametros() )? parentesis_der() )?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
void lista_parametros() :
{}
{
  try { 
  	parametros() ( fin_sentencia() parametros() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban uno o varios parámetros");
  }
}
void parametros() :
{}
{
  try {
  	clase_parametros()  declaracion()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un parámetro");
  }
}
void clase_parametros() :
{}
{
  try { 
  	<tVAL> | <tREF>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Tipo de parámetro desconocido. Se esperaba 'val' o 'ref'");
  }
}

void bloque_sentencias() :
{}
{
  try { 
    principio() lista_sentencias() fin()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un bloque se sentencias");
  }
}
void lista_sentencias() :
{}
{
  try {
    sentencia() ( sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban una o más sentencias");
  }
}
void sentencia() :
{}
{
  try {
    leer()
  | escribir()
  | instruccion()
  | seleccion()
  | mientras_que()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Sentencia desconocida");
  }
}

void leer() :
{}
{
  try {
  	<tLEER> parentesis_izq() lista_asignables() parentesis_der() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba sentencia leer");
  }
}
void lista_asignables() :
{}
{
  try {
  	identificadores()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba lista de asignables");
  }
}
void escribir() :
{}
{
  try {
  	<tESCRIBIR> parentesis_izq() lista_escribibles() parentesis_der()  fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba sentencia escribir");
  }
}
void lista_escribibles() :
{}
{
  try {
  	lista_expresiones()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba lista de escribibles");
  }
}

void asignacion() :
{}
{
  try {
    <tOPAS> expresion() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación");
  }
}

void instruccion() :
{}
{
  try {
  	identificador() ( ( argumentos() )? fin_sentencia() | asignacion() )
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación o una acción");
  }
}

void mientras_que() :
{}
{
  <tMQ>
  expresion()
  lista_sentencias()
  try {
  	<tFMQ>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura \"MQ\", \"FMQ\"");
  }
 
}

void seleccion() :
{}
{
  <tSI>
  expresion()
  <tENT>
  lista_sentencias()
  ( <tSI_NO> lista_sentencias() )*
  try {
  	<tFSI>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura \"SI\", \"FSI\"");
  }
}

void argumentos() :
{}
{
  try {
  	parentesis_izq() ( lista_expresiones() )? parentesis_der()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}


void lista_expresiones() :
{}
{
  try {
    expresion() ( sep_variable() expresion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de expresiones");
  }
}

void expresion() :
{}
{
  try {
  	expresion_simple()  ( operador_relacional()  expresion_simple() )?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresion");
  }
}
void operador_relacional() :
{}
{
  try {
  	<tIGUAL>
  | <tMENOR>
  | <tMAYOR>
  | <tMAI>
  | <tMEI>
  | <tNI>
 }
 catch (ParseException e) {
   ErrorSintactico.deteccion(e, "Se esperaba un operador relacional: '=', ' >', '<', '<=', '>=', o '!='");
 }
}
void expresion_simple() :
{}
{
  try {
    ( <tMAS> | <tMENOS> )? termino() ( operador_aditivo() termino() )*
    // termino() ( operador_aditivo() termino() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresion simple");
  }
}
void operador_aditivo() :
{}
{
  try {
    <tMAS>
  | <tMENOS>
  | <tOR>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador aditivo: '+', '-', o 'OR'");
  }
}
void termino() :
{}
{
  try {
    factor() ( operador_multiplicativo() factor() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un término");
  }
}
void operador_multiplicativo() :
{}
{
  try {
    <tPRODUCTO>
  | <tDIVISION>
  | <tMOD>
  | <tAND>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador multiplicativo: '*', '/', 'MOD', 'AND'");
  }
}
void factor() :
{}
{
  try {
    // <tMENOS> factor()
    <tNOT> factor()
  | parentesis_izq() expresion() parentesis_der()
  | <tENTACAR> parentesis_izq() expresion() parentesis_der()
  | <tCARAENT> parentesis_izq() expresion() parentesis_der()
  | identificador()
  | <tCONSTENTERA>
  | <tCONSTCHAR>
  | <tCONSTCAD>
  | <tTRUE>
  | <tFALSE>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un factor");
  }
}






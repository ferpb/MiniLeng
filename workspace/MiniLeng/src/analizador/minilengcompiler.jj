/*********************************************************************************
 * Especificación JavaCC para el lenguaje MiniLeng
 *
 * Fichero:    minilengcompiler.jj
 * Autor:      Fernando Peña (NIA: 756012)
 * Fecha:      29/03/2020
 * Versión:    v4.0
 * Asignatura: Procesadores de Lenguajes, curso 2019-2020
 **********************************************************************************/

options {
  static = true;
  ignore_case = true;
  // debug_parser = true;
}

PARSER_BEGIN(minilengcompiler)

package analizador;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.ArrayList;

import analizador.TokenMgrError;
import analizador.minilengcompilerTokenManager;
import analizador.SimpleCharStream;

import lib.lexico.TablaOcurrencias;
import lib.lexico.ErrorLexico;
import lib.sintactico.ErrorSintactico;
import lib.sintactico.PanicMode;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.*;
import lib.semantico.TablaSimbolos;
import lib.semantico.SimboloYaDeclaradoException;
import lib.semantico.SimboloNoEncontradoException;
import lib.semantico.InvocacionAccionException;
import lib.semantico.ErrorSemantico;
import lib.semantico.RegistroExpr;
import lib.semantico.RegistroOp;
import lib.semantico.UnderflowException;
import lib.semantico.OverflowException;
import lib.aviso.Aviso;

import lib.generacioncodigo.GeneracionCodigo;
import lib.generacioncodigo.ListaInstr;


public class minilengcompiler {

  	private static final String version = "2.2";
  	private static final String fecha_version = "abril de 2020";

	protected static Boolean verbose_mode = false;
	protected static Boolean panic_mode = false;
	protected static Boolean show_tokens = false;
	protected static Boolean debug = false;

	private static Boolean compilado_sin_errores = true;
	private static Boolean entrado_en_panic = false;

	public static TablaOcurrencias tabla_ocurrencias;
	private static TablaSimbolos tabla_simbolos;

	// Generacion de código
	private static GeneracionCodigo generacion_codigo;
	
	private static void help() {
		System.out.println("Uso: minilengcompiler [opciones] fichero\n");
		
      	System.out.println("Opciones:");
      	System.out.println("  -v, --verbose  Mostrar un resumen de los símbolos utilizados en el programa");
      	System.out.println("  -p, --panic	 Compila con panic mode");
      	System.out.println("  -t, --tokens   Muestra los tokens que se van reconociendo");
      	System.out.println("  -d, --debug    Muestra la tabla de símbolos antes y después de cerrar los bloques");
      	System.out.println("  -h, --help	 Imprimir ayuda (esta pantalla) y salir");
      	System.out.println("  --version      Imprimir información sobre la versión y salir");

      	System.exit(0);
    }

    private static void version() {
      	System.out.println("Compilador de MiniLeng -- version " + version + " (" + fecha_version + ")");
    	System.out.println("Autor: Fernando Peña Bes (NIA: 756012)\n");
    	
		System.out.println("  Prácticas de la asignatura: Procesadores de Lenguajes");
		System.out.println("  Curso 2019-2020");
		System.out.println("  Universidad de Zaragoza");
		System.out.println("");
		System.out.println("Programado con JavaCC");

      	System.exit(0);
    }

    private static void opcionInvalida(String opcion) {
        System.err.println("Error: Opción inválida: '" + opcion + "'\n");
        help();
    }

    private static String procesarArgumentos(String args[]) {
      	String fichero_entrada = null;
		ArrayList<String> opciones = new ArrayList<String>();

      	// Obtener opciones
		for (String arg : args) {
		    if (arg.charAt(0) == '-') {
		      // opciones
		      if (arg.length() == 1) {
		          opcionInvalida(arg);
		      }
		      else if (arg.charAt(1) == '-') {
		          opciones.add(arg);
		      }
		      else {
		      	  for (String opt : arg.substring(1).split("")) {
		      	      opciones.add("-" + opt);
		      	  }
		      }
		    }
		    else {
		      // fichero de entrada
		      fichero_entrada = arg;
		      break;
		    }
		}

		// Activar opciones
		for (String opt : opciones) {
		    switch(opt) {
				case "-h":
				case "--help":
			    	help();
			    	break;
			    case "--version":
			        version();
			    	break;
			  	case "-v":
				case "--verbose":
					verbose_mode = true;
					break;
				case "-p":
				case "--panic":
					panic_mode = true;
					break;
				case "-t":
				case "--tokens":
		        	show_tokens = true;
		        	break;
		        case "-d":
		        case "--debug":
		        	debug = true;
		        	break;
				default:
				    opcionInvalida(opt);
		    }
		}
		return fichero_entrada;
	}


	public static void main(String args []) throws ParseException {
	  
		// Entrada al programa
    	InputStream stream = System.in;
    	String fichero_entrada = procesarArgumentos(args);

		if (fichero_entrada != null) {
			// Si el fichero no terminal en .ml, error
			if (!fichero_entrada.endsWith(".ml")) {
        		System.err.println("Error: El fichero a compilar tiene que tener extensión .ml");
        		System.err.println("          Fichero introducido: '" + fichero_entrada + "'");
        		System.exit(0);
			}

			// Ejecutar el compilador con los fichero introducidos
			// System.out.println("MiniLeng: Leyendo el fichero '" + fichero_entrada + "'...");
      		try {
        		stream = new FileInputStream(fichero_entrada);
      		}
      		catch (FileNotFoundException e) {
        		System.err.println("Error: No se ha encontrado el fichero '" + fichero_entrada + "'");
        		System.exit(0);
      		}
		}
		else {
  			help();
		}

		// Inicializar generación de código
		// Cambiar extensión .ml por .code
	  	String fichero_salida = fichero_entrada.substring(0, fichero_entrada.length() - 2) + "code";
	  	generacion_codigo = new GeneracionCodigo(fichero_salida);

  		// Crear e inicializar tabla de ocurrencias
  		tabla_ocurrencias = new TablaOcurrencias(show_tokens);

  		// Crear e inicializar tabla de símbolos
  		tabla_simbolos = new TablaSimbolos();

		// Ejecución del compilador
        try {
    		minilengcompiler parser = new minilengcompiler(stream);
    		minilengcompiler.programa();
        }
        catch (Exception e) {
      		// TODO: ELIMINAR ESTO
      		System.err.println(e.getMessage());

            System.err.println("Error en el compilador");
            System.err.println("Cabeza de lectura: (línea " + token.beginLine + ", columna " + token.beginColumn + ") " + token);
           	throw e;
        }
        catch (Error e) {
		  	// Detectado error léxico

		  	// TODO: ELIMINAR ESTO
		  	System.err.println(e.getMessage());

			SimpleCharStream entrada = minilengcompilerTokenManager.input_stream;
			String error;

			try {
				error = Character.toString(entrada.readChar());
			}
			catch (java.io.IOException fin_fichero) {
		  		error = "<EOF>";
			}

			ErrorLexico.deteccion(entrada.getEndLine(), entrada.getEndColumn(), error, TokenMgrError.addEscapes(error));
		}

		// Imprimir resultados de la compilación
		resultadosCompilacion(fichero_salida);
		if (compilado_sin_errores) {
		  generacion_codigo.escribirPrograma();
		}
    }

	static void resultadosCompilacion(String fichero_salida) {
	  	System.out.println();

		// Mostrar tabla de ocurrencias
    	if (verbose_mode) {
      		tabla_ocurrencias.imprimirTabla();
    	}


	  	// Mostrar contadores de errores
		if (ErrorLexico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores léxicos: " + ErrorLexico.getContadorErrores());
		}

		if (ErrorSintactico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores sintácticos: " + ErrorSintactico.getContadorErrores());
		}

		if (ErrorSemantico.getContadorErrores() > 0) {
		  compilado_sin_errores = false;
		  System.out.println("Errores semánticos: " + ErrorSemantico.getContadorErrores());
		}

		if (Aviso.getContadorAvisos() > 0) {
			System.out.println("Avisos: " + Aviso.getContadorAvisos());
		}

	    if (PanicMode.getContadorErrores() > 0) {
		  	entrado_en_panic = true;
		  	System.out.println("Número de activaciones del panic mode: " + PanicMode.getContadorErrores());
		}

		// Resultados compilacion
		if (!compilado_sin_errores) {
		  	System.out.println("\nNo se ha podido compilar el programa.");
		}
		else if (entrado_en_panic) {
		  	System.out.println("\nSe ha activado el panic mode durante la compilación. Es necesario corregir los errores y volver a compilar.");
		}
		else {
		  	System.out.println("\nCompilación finalizada. Se ha generado el fichero '" + fichero_salida + "'");
		}
	}
}

PARSER_END(minilengcompiler)



/**** Análisis léxico ****/

SKIP : {  " "| "\r"| "\t"| "\n"
| < "%"~["%"] > : COMENTARIO
| "%%"          : MULTICOMENTARIO}

// Ignorar comentarios en la entrada
< COMENTARIO > SKIP : {
  "\n" : DEFAULT
}

<COMENTARIO> MORE : {
   < ~[] >
}

<MULTICOMENTARIO> SKIP : {
  "%%" : DEFAULT
}

<MULTICOMENTARIO> MORE : {
   < ~[] >
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPROGRAMA);
  }
| < tVAR : "var" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAR);
  }
| < tPRINCIPIO : "principio" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPRINCIPIO);
  }
| < tFIN : "fin" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFIN);
  }
| < tSI : "si" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI);
  }
| < tENT : "ent" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENT);

  }
| < tSI_NO : "si_no" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI_NO);
  }
| < tFSI : "fsi" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFSI);
  }
| < tMQ : "mq" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tMQ);
  }
| < tFMQ : "fmq" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFMQ);
  }
| < tESCRIBIR : "escribir" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tESCRIBIR);
  }
| < tLEER : "leer" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tLEER);
  }

  // Funciones predefinidas
| < tENTACAR : "entacar" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENTACAR);
  }
| < tCARAENT : "caraent" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tCARAENT);
  }

  // Funciones
| < tACCION : "accion" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tACCION);
  }
| < tVAL : "val" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAL);
  }
|  < tREF : "ref" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tREF);
  }
}


TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tENTERO);
  }
| < tBOOLEANO : "booleano" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tBOOLEANO);
  }
| < tCARACTER : "caracter" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tCARACTER);
  }
}


TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_IZQ);
  }
| < tLLAVE_DER : "}" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_DER);
  }
| < tPARENTESIS_IZQ : "(" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_IZQ);
  }
| < tPARENTESIS_DER : ")" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_DER);
  }
}


TOKEN : /* VECTORES */
{
  < tCORCHETE_IZQ : "[" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_IZQ);
  }

| < tCORCHETE_DER : "]" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_DER);
  }
}


TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tOPAS);
  }

| < tFIN_SENTENCIA : ";" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tFIN_SENTENCIA);
  }
| < tSEP_VARIABLE : "," >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tSEP_VARIABLE);
  }

  // Aritméticos
| < tMAS : "+" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMAS);
  }
| < tMENOS : "-" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMENOS);
  }
| < tPRODUCTO : "*" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tPRODUCTO);
  }
| < tDIVISION : "/" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIVISION);
  }
| < tMOD : "mod" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMOD);
  }
| < tDIV : "div" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIV);
  }

  // Lógicos
| < tAND : "and" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tAND);
  }
| < tOR : "or" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tOR);
  }
| < tNOT : "not" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNOT);
  }
| < tMAYOR : ">" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAYOR);
  }
| < tMENOR : "<" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMENOR);
  }
| < tIGUAL : "=" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tIGUAL);
  }
| < tMAI : ">=" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAI);
  }
| < tMEI : "<=" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMEI);
  }
| < tNI : "<>" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNI);
  }
}


TOKEN : /* VALORES */
{
  < #DIGITO : [ "0"-"9" ] >
| < #LETRA : [ "a"-"z" ] >

  // Booleanos
| < tTRUE : "true" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tTRUE, "True");
  }
| < tFALSE : "false" >
  {
     minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tFALSE, "False");
  }

  // Identificadores
| < tIDENTIFICADOR : (< LETRA > | "_"(< LETRA > | < DIGITO >))(("_")?(< LETRA > | < DIGITO >))* >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tIDENTIFICADOR, matchedToken.image);
  }

  // Enteros
  // | < tCONSTENTERA : ("+" | "-")?(["0"-"9"])+ >
| < tCONSTENTERA : (["0"-"9"])+ >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTENTERA, matchedToken.image);
  }

   // Caracteres
| < tCONSTCHAR : "\""(~["\""])?"\"" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCHAR, matchedToken.image);
  }

  // Cadena de caracteres
| < tCONSTCAD : "\""(~["\""])*"\"" >
  {
    minilengcompiler.tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCAD, matchedToken.image);
  }
}



/**** Análisis sintáctico ****/

// Inicio programa

/*
 * programa	::=	<tPROGRAMA> identificador fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias <EOF>
 */
int programa() :
{
  int nivel = 0;
  tabla_simbolos.inicializar_tabla();

  Token t = null;

  ListaInstr l = new ListaInstr();
  ListaInstr lAcciones = null;
  ListaInstr lSentencias = null;

  Integer etiq;
}
{
  try {
  	<tPROGRAMA>
  	t = identificador()
  	{
  	  	System.out.println("Leído programa " + t.image);
  		tabla_simbolos.introducir_programa(t.image, 0);
  	}

  	fin_sentencia()
  	declaracion_variables()
  	lAcciones = declaracion_acciones()
  	lSentencias = bloque_sentencias() < EOF >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "La declaración del programa es incorrecta");
  }

  {
     if (debug) { 
       System.out.println("Antes de cerrar el programa. Nivel " + nivel);
       tabla_simbolos.imprimirTabla();
     }

 	 // Cerrar el programa y limpiar la tabla de símbolos
     tabla_simbolos.eliminar_variables(nivel);
 	 tabla_simbolos.eliminar_acciones(nivel);
  	 tabla_simbolos.eliminar_programa();

	 if (debug) { 
 	   System.out.println("Después de cerrar programa");
  	   tabla_simbolos.imprimirTabla();
     }

  	  // Generación de código
  	 if (t != null) { 
  	  	l.addPrograma(t.image, generacion_codigo.nuevaEtiqueta(), lAcciones, lSentencias);
  	  	generacion_codigo.guardarPrograma(l);
  	 }
  }

  {
	// Fin del compilador
    return 0;
  }

}




// Declaraciones de separadores y limitadores de bloque

void fin_sentencia() :
{}
{
  try {
    < tFIN_SENTENCIA >
  }
  catch (ParseException e) {
    // Si el modo pánico está activado, descartar entrada hasta el siguiente ;
    if (panic_mode) {
      PanicMode.iniciar(e, "Se esperaba ';'", tFIN_SENTENCIA, ";");
    }
    else {
      ErrorSintactico.deteccion(e, "Se esperaba ';'");
    }
  }
}
void sep_variable() :
{}
{
  try {
    < tSEP_VARIABLE >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ','");
  }
}

void parentesis_izq() :
{}
{
  try {
    < tPARENTESIS_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta paréntesis de cierre: ')'");
  }
}
void parentesis_der() :
{}
{
  try {
    < tPARENTESIS_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '('");
  }
}

void corchete_izq() :
{}
{
  try {
    < tCORCHETE_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '['");
  }
}
void corchete_der() :
{}
{
  try {
    < tCORCHETE_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ']'");
  }
}

Integer longitud_const() :
{
  Token t;
  Integer len = null;
}
{
  try {
    t = < tCONSTENTERA >
    {
      len = Integer.parseInt(t.image);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una constante entera");
  }
  {
    return len;
  }
}

void principio() :
{}
{
  try {
    < tPRINCIPIO >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de principio de bloque: 'principio'");
  }
}
void fin() :
{}
{
  try {
    < tFIN >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador fin de bloque: 'fin'");
  }
}

Token identificador() :
{
  Token t = null;
}
{
  try {
  	t = < tIDENTIFICADOR >
  }
  catch(ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un identificador");
  }
  {
    return t;
  }
}




// Declaracion de variables

/*
 * declaracion_variables ::= ( declaracion fin_sentencia )*
 */
void declaracion_variables() :
{}
{
  try {
    {
      System.out.println("Entrado en declaracion de variables");
    }
  	( declaracion() fin_sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion ::= tipo_variables identificadores
 */
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores;
}
{
  try {
  	tipo = tipo_variables()
  	identificadores(tipo)
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de variables");
  }
}
/*
 * tipo_variables	::=	( <tENTERO> | <tCARACTER> | <tBOOLEANO> )
 */
Tipo_variable tipo_variables() :
{
  Tipo_variable variable = null;
}
{
  try {
  	<tENTERO> { variable = Tipo_variable.ENTERO; }
  | <tCARACTER> { variable = Tipo_variable.CHAR; }
  | <tBOOLEANO> { variable = Tipo_variable.BOOLEANO; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de dato");
  }
  {
    return variable;
  }
}
/*
 * identificadores	::=	(identificador | vector) ( sep_variable (identificador | vector) )*
 */
void identificadores(Tipo_variable tipo) :
{
}
{
  try {
  	identificador_declaracion(tipo) (sep_variable() identificador_declaracion(tipo))*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba uno o varios identificadores o vectores");
  }
}

void identificador_declaracion(Tipo_variable tipo) :
{
  Token id = null;
  Integer len = null;
}
{
  try {
    id = identificador() ( corchete_izq() len = longitud_const() corchete_der() )?
    {
      try {
        if (id != null && tipo != null) {
          System.err.println("Identificador declaracion " + id.image + " " + len);
          if (len == null) {
            // variable
            System.out.println("Se va a introducir una variable: " + id.image);
            tabla_simbolos.introducir_variable(id.image, tipo, generacion_codigo.getNivel(), generacion_codigo.nuevaVariable());
          }
          else {
            // vector
            System.out.println("Se va a introducir una variable vector: " + id.image + " " + len);
            tabla_simbolos.introducir_variable_vector(id.image, tipo, len, generacion_codigo.getNivel(), generacion_codigo.nuevoVector(len));
          }
  	    }
  	  }
  	  catch (SimboloYaDeclaradoException e) {
  	    ErrorSemantico.deteccion(e, id);
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la declaración de una variable o vector");
  }
}



// Declaración de acciones

/*
 * declaracion_acciones	::=	( declaracion_accion )*
 */
ListaInstr declaracion_acciones() :
{
  ListaInstr l = new ListaInstr();

  ListaInstr lDeclAccion;
}
{
  try {
  	(
  	  lDeclAccion = declaracion_accion()
  	  {
  	    l.concatenarLista(lDeclAccion);
  	  }
  	)*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
  {
    return l;
  }
}
/*
 * declaracion_accion	::=	cabecera_accion fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias
 */
ListaInstr declaracion_accion() :
{
  Token t = token.next;
  
  ListaInstr l = new ListaInstr();

  ListaInstr lCabecera = null;
  ListaInstr lAcciones = null;
  ListaInstr lSentencias = null;
}
{
  try {
  	lCabecera = cabecera_accion() fin_sentencia()
  	declaracion_variables()
  	lAcciones = declaracion_acciones()
  	lSentencias = bloque_sentencias()

  	{

	  if (debug) { 
  	    System.out.println("Antes de cerrar la acción: " + t.next.image + ". Nivel " + generacion_codigo.getNivel());
        tabla_simbolos.imprimirTabla();
      }

  	  // Cerrar el bloque y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(generacion_codigo.getNivel());
  	  tabla_simbolos.eliminar_parametros(generacion_codigo.getNivel());
  	  tabla_simbolos.eliminar_acciones(generacion_codigo.getNivel());
  	  generacion_codigo.cerrarBloque();

	  if (debug) { 
  	    System.out.println("Después de cerrar la acción");
  	    tabla_simbolos.imprimirTabla();
  	  }

  	  // Generación de código
  	  l.addAccion(t.next.image, generacion_codigo.nuevaEtiqueta(), lCabecera, lAcciones, lSentencias);
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de acción");
  }
  {
    return l;
  }
}
/*
 * cabecera_accion	::=	<tACCION> identificador ( parametros_formales )?
 */
ListaInstr cabecera_accion() :
{
  Token id;
  Simbolo s = null;

  ArrayList<Simbolo> listaParametros;
  
  ListaInstr l = new ListaInstr();
}
{
  try {
  	<tACCION>

  	id = identificador()
  	{
  	  // Procesar símbolo del identificador
  	  if (id != null) {
  	    try {
  	      System.out.println("Se va a introducir una accion " + id.image);
  	      // TODO: pensar en cómo funciona dir en las acciones

  	      s = tabla_simbolos.introducir_accion(id.image, generacion_codigo.getNivel(), generacion_codigo.nuevaEtiqueta());
		  
		  // Generación de código
		  // Añadir etiqueta de inicio de acción
  	      l.addEtiqueta(s.getDir());
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      ErrorSemantico.deteccion(e, id);
  	    }
  	    generacion_codigo.abrirBloque();
  	  }
  	}

  	(
  	  listaParametros = parametros_formales(s)
  	  {
  	    System.out.println("El tamaño de la lista de parámetros formales es " + listaParametros.size());
  	    // Generación de código
  	    // Recuperar los parámetros de la invocación. Hay que hacerlo en orden inverso
  	    for (int i = listaParametros.size(); i > 0; i--) {
  	      System.out.println("Añadir parametro");
  	      l.addRecuperarPar(listaParametros.get(i - 1), generacion_codigo.getNivel());
  	    }
  	  }
  	)?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta la cabecera de la acción");
  }
  {
    return l;
  }
}

/*
 * parametros_formales	::=	parentesis_izq ( parametros ( fin_sentencia parametros )* )? parentesis_der
 */
ArrayList<Simbolo> parametros_formales(Simbolo s) :
{
  ArrayList<Simbolo> parametros;
  
  ArrayList<Simbolo> listaParametros = new ArrayList<Simbolo>();
}
{
  try {
    parentesis_izq()
    (
      parametros = parametros(s)
      {
        listaParametros.addAll(parametros);
      }
      (
        fin_sentencia() parametros = parametros(s)
        {
          listaParametros.addAll(parametros);
        }
      )*
     )?
    parentesis_der()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban los parametros formales de la accion");
  }
  {
    return listaParametros;
  }
}

/*
 * parametros	::=	clase_parametros tipo_variables identificadores
 */
ArrayList<Simbolo> parametros(Simbolo s) :
{
  Clase_parametro clase;
  Tipo_variable tipo;

  ArrayList<Simbolo> listaParametros = new ArrayList<Simbolo>();
}
{
  try {
    clase = clase_parametros()
    tipo = tipo_variables()
    listaParametros = lista_parametros(clase, tipo, s)
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban parámetros");
  }
  {
    return listaParametros;
  }
}
/*
 * lista_parametros	::=	parametros ( sep_variable parametros )*
 */
ArrayList<Simbolo> lista_parametros(Clase_parametro clase, Tipo_variable tipo, Simbolo s) :
{
  ArrayList<Simbolo> listaParametros = new ArrayList<Simbolo>();

  Simbolo par;
}
{
  try {
    par = identificador_parametro(clase, tipo, s)
    {
      if (par != null) { 
        listaParametros.add(par);
      }
    }
    (
      sep_variable() par = identificador_parametro(clase, tipo, s)
      {
        if (par != null) { 
          listaParametros.add(par);
        }
      }
    )*
  }
  catch (ParseException e) {
	ErrorSintactico.deteccion(e, "Se esperaba una lista de parámetros");
  }
  {
    return listaParametros;
  }
}
/*
 * clase_parametros	::=	( <tVAL> | <tREF> )
 */
Clase_parametro clase_parametros() :
{
  Clase_parametro clase = null;
}
{
  try {
  	  <tVAL> { clase = Clase_parametro.VAL; }
    | <tREF> { clase = Clase_parametro.REF; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de parametro");
  }
  {
    return clase;
  }
}


Simbolo identificador_parametro(Clase_parametro clase, Tipo_variable tipo, Simbolo s) :
{
  Token id;
  Integer len = null;
  Simbolo par = null;
}
{
  try {
    id = identificador() ( corchete_izq() len = longitud_const() corchete_der() )?
    {
      if (id != null && clase != null && tipo != null) {
        try {
          if (len == null) {
            // parametro
	        System.out.println("Se va a introducir un parametro: " + id.image + " " + tipo + " " + clase);
  	        par = tabla_simbolos.introducir_parametro(id.image, tipo, clase, generacion_codigo.getNivel(), generacion_codigo.nuevaVariable());
			System.out.println("Se ha introducido el parámetro");
          }
          else {
            // parametro vector
            System.out.println("Se va a introducir un parametro vector: " + id.image + " " + tipo + " " + clase);
	        par = tabla_simbolos.introducir_parametro_vector(id.image, tipo, clase, len, generacion_codigo.getNivel(), generacion_codigo.nuevoVector(len));
          }
        }
        catch (SimboloYaDeclaradoException e) {
          System.out.println("Excepción");
          // Si el símbolo está ya declarado, se introduce como un parámetro anónimo
  	      // en la lista de parametros para poder hacer la comprobación de signatura
  	      // al llamar a la función, pero no se mete en la tabla de simbolos.
  	      ErrorSemantico.deteccion(e, id);
  	      par = new Simbolo();
  	      par.introducir_parametro("__anonymus", tipo, clase, generacion_codigo.getNivel(), generacion_codigo.nuevaVariable());
        }
      }
    }
  }
  catch (ParseException e) {
	ErrorSintactico.deteccion(e, "Se esperaba un parámetro");
  }
  {
    if (s != null && par != null) {
      System.out.println("Añadido parametro " + par + " a la accion " + s);
      // añadir el parametro a la acción
      s.addParametro(par);
    }
    // par.setInicializado(true);
    System.out.println("Devolver parametro " + par);
    return par;
  }
}




// Sentencias

/*
 * bloque_sentencias	::=	principio lista_sentencias fin
 */
ListaInstr bloque_sentencias() :
{
  ListaInstr l = new ListaInstr();
}
{
  try {
    principio() l = lista_sentencias() fin()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un bloque se sentencias");
  }
  {
    return l;
  }
}
/*
 * lista_sentencias	::=	sentencia ( sentencia )*
 */
ListaInstr lista_sentencias() :
{
  ListaInstr l = new ListaInstr();
  ListaInstr lSentencia;
}
{
  try {
    lSentencia = sentencia()
    {
      l.concatenarLista(lSentencia);
    }
    (
      lSentencia = sentencia()
      {
        l.concatenarLista(lSentencia);
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban una o más sentencias");
  }
  {
    return l;
  }
}
/*
 * sentencia	::=	( leer | escribir | identificacion | seleccion | mientras_que )
 */
ListaInstr sentencia() :
{
  ListaInstr l = new ListaInstr();
}
{
  try {
    l = leer()
  | l = escribir()
  | l = identificacion()
  | l = seleccion()
  | l = mientras_que()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una sentencia");
  }
  {
    return l;
  }
}

/*
 * leer	::=	<tLEER> parentesis_izq lista_asignables parentesis_der fin_sentencia
 */
ListaInstr leer() :
{
  Token t;
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  
  ListaInstr l = new ListaInstr();
}
{
  try {
  	t = <tLEER> parentesis_izq() listaExpr = lista_asignables(t) parentesis_der() fin_sentencia()
  	{
  	  // Generación de código
  	  for (RegistroExpr expr : listaExpr) {
  	    if (expr.esChar()) {
  	      l.addLeerChar(expr.getListaInstr());
  	    }
  	    else {
  	      l.addLeerEnt(expr.getListaInstr());
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia leer");
  }
  {
    return l;
  }
}
/*
 * lista_asignables	::=	identificadores
 */
ArrayList<RegistroExpr> lista_asignables(Token t) :
{
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();

  ArrayList<RegistroExpr> listaEscribibles = new ArrayList<RegistroExpr>();
}
{
  try {
  	listaExpr = lista_expresiones()
  	{
  	  System.out.println("Llegado escribir");
  	  System.out.println("Size: " + listaExpr.size());
  	  
  	  for (int i = 0; i < listaExpr.size(); i++) {
  	    if (listaExpr.get(i).esVector()) {
          ErrorSemantico.deteccion(new InvocacionAccionException(),
           "La expresión " + (i + 1) + " es un vector, no es asignable en una instrucción leer", t);
  	    }
        else if (listaExpr.get(i).esParVal()) {
          ErrorSemantico.deteccion(new InvocacionAccionException(),
            "La expresión " + (i + 1) + " es un parámetro por valor, no es asignable", t);
        }
        else if (!listaExpr.get(i).esAsignable()) {
	       ErrorSemantico.deteccion(new InvocacionAccionException(),
              "La expresión " + (i + 1) + " no es asignable", t);
  	    }
  	    else {
  	      // System.out.println("Se puede asignar");
  	      System.out.println("iteracion: " + i);
  	      listaEscribibles.add(listaExpr.get(i));
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de asignables");
  }
  {
    return listaEscribibles;
  }
}
/*
 * escribir	::=	<tESCRIBIR> parentesis_izq lista_escribibles parentesis_der fin_sentencia
 */
ListaInstr escribir() :
{
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();

  ListaInstr l = new ListaInstr();
}
{
  try {
  	<tESCRIBIR> parentesis_izq() listaExpr = lista_escribibles() parentesis_der()  fin_sentencia()
  	{
  	   // Generación de código
  	   for (RegistroExpr expr : listaExpr) { 
  	   	if (expr.esEnt()) {
  	   	  l.addEscribirEnt(expr.getListaInstr());
  	   	}
  	   	else if (expr.esChar()) {
  	   	  l.addEscribirChar(expr.getListaInstr());
  	   	}
  	   	else if (expr.esBool()) {
  	   	  if (expr.getValorBool() != null) {
  	   	    if (expr.getValorBool()) {
  	   	      l.addEscribirCad("True");
  	   	    }
  	   	    else {
  	   	      l.addEscribirCad("False");
  	   	    }
  	   	  }
  	   	  else {
  	   	    l.addEscribirBool(expr.getListaInstr(), generacion_codigo.nuevaEtiqueta(), generacion_codigo.nuevaEtiqueta());
  	   	  }
  	   	}
  	   	else if (expr.esCad()) {
  	   	  l.addEscribirCad(expr.getValorCad());
  	   	}
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia escribir");
  }
  {
    return l;
  }
}
/*
 * lista_escribibles	::=	escribible (sep_variable escribible)*
 */
ArrayList<RegistroExpr> lista_escribibles() :
{
  RegistroExpr reg;
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();

}
{
  try {
    // Expresiones y cadenas de caracteres
    reg = escribible()
    {
      if (reg != null) {
        listaExpr.add(reg);
      }
    }
    (      sep_variable()
      reg = escribible()
      {
        if (reg != null) {
          listaExpr.add(reg);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de escribibles");
  }
  {
    return listaExpr;
  }
}

RegistroExpr escribible() :
{
  RegistroExpr reg = null;
  Token t;
}
{
  try {
    reg = expresion()
  | t = < tCONSTCAD>
    {
      if (reg == null) {
        reg = new RegistroExpr();
        reg.setTipoCad();
        String cad = t.image;
        // Eliminar el primer y último caracteres, que serán "
        cad = cad.substring(1);
        cad = cad.substring(0, cad.length() - 1);
        reg.setValorCad(cad);
      }
      else if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden escribir vectores", token);
        reg = null;
      }
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un escribible");
  }
  {
    return reg;
  }
}


/*
 * mientras_que	::=	<tMQ> expresion lista_sentencias <tFMQ>
 */
ListaInstr mientras_que() :
{
  Token t;
  RegistroExpr reg;
  Boolean ok = true;

  ListaInstr l = new ListaInstr();

  ListaInstr lSentencias;
}
{
  t = <tMQ>
  reg = expresion()
  {
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en el 'mientras_que' debe ser un booleano", t);
      ok = false;
    }
    else if (reg.esBool() && reg.getValorBool() != null) {
      if (reg.getValorBool()) {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'true', se produce un bucle infinito", t);
      }
      else {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'false', el interior del bloque es código muerto", t);
        ok = false;
      }
    }
  }
  lSentencias = lista_sentencias()
  try {
  	<tFMQ>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura MQ: 'FMQ'");
  }

  {
    // Generación de código

    // Si va a ser código muerto, no se genera código
    if (ok) {
   	  l.addMientrasQue(reg.getListaInstr(), lSentencias, generacion_codigo.nuevaEtiqueta(), generacion_codigo.nuevaEtiqueta());
    }

    return l;
  }
}

/*
 * seleccion	::=	<tSI> expresion <tENT> lista_sentencias ( <tSI_NO> lista_sentencias )* <tFSI>
 */
ListaInstr seleccion() :
{
  Token t;
  RegistroExpr reg;

  Boolean ok = true;

  ListaInstr l = new ListaInstr();

  ListaInstr lSi;
  ListaInstr lSino = null;
}
{
  t = <tSI>
  reg = expresion()
  try {
  	<tENT>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el token 'ENT'");
  }
  lSi = lista_sentencias()
  ( <tSI_NO> lSino = lista_sentencias() )*
  try {
  	<tFSI>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura SI: 'FSI'");
  }

  {
	// Generación de código
	// Si va a ser código muerto no se genera código
    
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en la selección debe ser un booleano", t);
    }
    else if (reg.esBool() && reg.getValorBool() != null) {
      if (lSino == null) {
        if (reg.getValorBool()) {
          l.concatenarLista(lSi);
        }
        else {
          Aviso.deteccion("La expresión del 'si' es siempre 'false', el interior del bloque es código muerto", t);
        }
      }
      else {
        if (reg.getValorBool()) {
          Aviso.deteccion("La expresión de la selección es siempre 'true', el interior del bloque 'si_no' es código muerto", t);
          l.concatenarLista(lSi);
        }
        else {
          Aviso.deteccion("La expresión de la selección es siempre 'false', el interior del bloque 'si' es código muerto", t);
          l.concatenarLista(lSino);
        }
      }
    }
    else {
	  if (lSino != null) {
	    l.addSeleccion(reg.getListaInstr(), lSi, lSino, generacion_codigo.nuevaEtiqueta(), generacion_codigo.nuevaEtiqueta());
	  }
	  else {
	    l.addSeleccionSimple(reg.getListaInstr(), lSi, generacion_codigo.nuevaEtiqueta());
	  }
    }
    
	return l;
  }
}






/*
 * identificacion	::=	identificador ( ( argumentos )? fin_sentencia | asignacion )
 */
ListaInstr identificacion() :
{
  Token t;
  RegistroExpr indice = null;

  Simbolo s = null;
  Tipo_variable tpID = Tipo_variable.DESCONOCIDO;

  ListaInstr l = new ListaInstr();

  ListaInstr lArgs = null;
  ListaInstr lAsig;
}
{
  try {
  	t = identificador()
  	{
	  try {
  	    s = tabla_simbolos.buscar_simbolo(t.image);
  	  }
  	  catch (SimboloNoEncontradoException e) {
  	    ErrorSemantico.deteccion(e, t);
  	  }
  	}

    (
      ( corchete_izq() indice = expresion() corchete_der() )? lAsig = asignacion(s, indice, t) fin_sentencia()
      {
        // Generación de código
        l.concatenarLista(lAsig);
      }

    | ( lArgs = argumentos(s, t) )? fin_sentencia()
      {
        if (s != null) {
          if (!s.ES_ACCION()) {
            ErrorSemantico.deteccion(new InvocacionAccionException(),
              "El simbolo no es una accion", t);
          }
          else if (!s.getListaParametros().isEmpty() && lArgs == null) {
            ErrorSemantico.deteccion(new InvocacionAccionException(),
  	          "La acción requiere " + s.getListaParametros().size() + " argumentos", t);
          }
          else {
            // Generación de código
            // Concatenar las instrucciones de los argumentos si las hay
            if (lArgs != null) {
              l.concatenarLista(lArgs);
            }
            l.addInvocacionAccion(s, generacion_codigo.getSig() - 1, generacion_codigo.getNivel());
          }
        }
      }
    )
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación o una acción");
  }
  {
    return l;
  }
}



/*
 * asignacion	::=	<tOPAS> expresion fin_sentencia
 */
ListaInstr asignacion(Simbolo s, RegistroExpr indice, Token izq) :
{
  RegistroExpr reg;
  Token t;

  ListaInstr l = new ListaInstr();
}
{
  try {
    t = <tOPAS> reg = expresion()
    {
      if (s != null) {
        if (!s.ES_VECTOR() && indice != null) {
          ErrorSemantico.deteccion("El símbolo no es un vector", izq);
        }
        else if (s.ES_ACCION()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a una acción", izq);
  	    }
  	    else if (s.ES_PROGRAMA()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a un programa", izq);
  	    }
  	    else if (s.ES_PARAMETRO() && s.ES_VALOR()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a un parámetro por valor", izq);
  	   	}
  	   	else if (s.ES_VARIABLE() || (s.ES_PARAMETRO() && s.ES_REFERENCIA())) {
  	   	  if ((!reg.esDesc() && s.getVariable() != reg.getTipo()) || (s.ES_VECTOR() ^ (indice != null)) != reg.esVector()) {

  	   	    System.err.print(s.getVariable() + " " + reg.getTipo() + " " + s.ES_VECTOR() + " " + (indice == null) + " " + reg.esVector() + "\n");
            ErrorSemantico.deteccion("Tipos incompatibles en la asignación", t);
  	   	  }
  	   	  else if (s.ES_VECTOR() && reg.esVector() && s.getLongitud() != reg.getLongitud()) {
  	   	    ErrorSemantico.deteccion("No se puede realizar la asignación directa de vectores de diferente longitud", t);
  	   	  }
  	   	  else {
  	   	    // La asignación es correcta
  	   	    System.err.println("La asignación es correcta");

  	   	    // s.setInicializado(true);

  	   	    // Generación de código
  	   	    if (s.ES_VECTOR() && indice == null) {
  	   	      System.err.println("Asignación directa de vectores");
  	   	      // Asignación directa de vectores
  	   	      l.addAsigVectores(s, reg.getSimbolo(), generacion_codigo.getNivel());
  	   	    }
  	   	    else {
  	   	      // Asignación de valor a variable
  	   	      l.addAsigVariable(s, generacion_codigo.getNivel(), indice, reg.getListaInstr());
  	   	    }
  	   	  }
  	   	}
  	  }
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación");
  }
  {
    return l;
  }
}




/*
 * argumentos	::=	parentesis_izq ( lista_expresiones )? parentesis_der
 */
ListaInstr argumentos(Simbolo s, Token t) :
{
  ArrayList<RegistroExpr> listaExpr = null;
  ArrayList<Simbolo> listaParams;

  ListaInstr listaInstr = null;
}
{
  try {
  	parentesis_izq() ( listaExpr = lista_expresiones() )? parentesis_der()
	{
	  if (s != null && listaExpr != null && s.ES_ACCION()) {
	    listaInstr = new ListaInstr();

	    listaParams = s.getListaParametros();

  	  	if (listaExpr.size() != listaParams.size()) {
  	      ErrorSemantico.deteccion(new InvocacionAccionException(),
  	      "El número de argumentos es incorrecto, se esperaban " + listaParams.size(), t);
  	    }
  	    else {
          for (int i = 0; i < listaExpr.size(); i++) {
            RegistroExpr arg = listaExpr.get(i);
            Simbolo param = listaParams.get(i);

            if (!arg.esDesc()) {

              // Comprobar tipo
              if ((arg.getTipo() != param.getVariable() || arg.esVector() != param.ES_VECTOR())
                   || (arg.esVector() && param.ES_VECTOR() && arg.getLongitud() != param.getLongitud())) {

                String tipoEsperado = param.getVariableString();
                if (param.ES_VECTOR()) {
                  tipoEsperado += "[" + param.getLongitud() + "]";
                }

                ErrorSemantico.deteccion(new InvocacionAccionException(),
                  "El tipo del argumento " + (i + 1) + " no coincide con el del parámetro, se esperaba " + tipoEsperado, t);
              }

              // Comprobar que se pase como referencia un argumento asignable
              else if (param.ES_REFERENCIA() && arg.esParVal()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(),
                  "El argumento " + (i + 1) + " es un parámetro por valor, no es asignable y no se puede pasar por referencia", t);
			  }
              else if (param.ES_REFERENCIA() && !arg.esAsignable()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(),
                    "La expresión del argumento " + (i + 1) + " no es asignable, así que no se puede pasar por referencia", t);
              }
              else {
                // El argumento es válido
                System.err.println("El argumento es válido");

                // Generación de código
                listaInstr.addApilarArgumento(param, i, arg.getListaInstr());
              }
            }
          }
        }
      }
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de argumentos");
  }
  {
    return listaInstr;
  }
}








// Expresiones

/*
 * lista_expresiones	::=	expresion ( sep_variable expresion )*
 */
ArrayList<RegistroExpr> lista_expresiones() :
{
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  RegistroExpr reg;
}
{
  try {
    // Construir una lista con el tipo y clase de los argumentos
    reg = expresion()
    {
      listaExpr.add(reg);
    }
    (
      sep_variable()
      reg = expresion()
      {
        listaExpr.add(reg);
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de expresiones");
  }
  {
    return listaExpr;
  }
}


/*
 * expresion	::=	expresion_simple ( operador_relacional expresion_simple )?
 */
RegistroExpr expresion() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
  	reg1 = expresion_simple()
  	(
  	  op = operador_relacional()
  	  reg2 = expresion_simple()
  	  {
  	    if (op != null) {
  	   	  reg1 = RegistroExpr.operar(op, reg1, reg2);
  	   	}
  	  }
  	)?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión");
  }
  {
    // Generación de código
    reg1.sustituirConstante();

    return reg1;
  }
}
/*
 * operador_relacional	::=	( <tIGUAL> | <tMENOR> | <tMAYOR> | <tMAI> | <tMEI> | <tNI> )
 */
RegistroOp operador_relacional() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
  	t = <tIGUAL> { op = new RegistroOp(t, RegistroOp.Operador.IGUAL); }
  | t = <tMENOR> { op = new RegistroOp(t, RegistroOp.Operador.MENOR); }
  | t = <tMAYOR> { op = new RegistroOp(t, RegistroOp.Operador.MAYOR); }
  | t = <tMAI>   { op = new RegistroOp(t, RegistroOp.Operador.MAI); }
  | t = <tMEI>   { op = new RegistroOp(t, RegistroOp.Operador.MEI); }
  | t = <tNI>    { op = new RegistroOp(t, RegistroOp.Operador.NI); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador relacional: '=', ' >', '<', '<=', '>=', o '!='");
  }
  {
    return op;
  }
}
/*
 * expresion_simple	::=	termino ( operador_aditivo termino )*
 */
RegistroExpr expresion_simple() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
    reg1 = termino()
    (
      op = operador_aditivo()
      reg2 = termino()
      {
        if (op != null) {
          reg1 = RegistroExpr.operar(op, reg1, reg2);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión simple");
  }
  {
    // Generación de código
    reg1.sustituirConstante();
    
    return reg1;
  }
}
/*
 * operador_aditivo	::=	( <tMAS> | <tMENOS> | <tOR> )
 */
RegistroOp operador_aditivo() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
    t = <tMAS>   { op = new RegistroOp(t, RegistroOp.Operador.MAS); }
  | t = <tMENOS> { op = new RegistroOp(t, RegistroOp.Operador.MENOS); }
  | t = <tOR>    { op = new RegistroOp(t, RegistroOp.Operador.OR); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador aditivo: '+', '-', o 'OR'");
  }
  {
    return op;
  }
}
/*
 * termino	::=	factor ( operador_multiplicativo factor )*
 */
RegistroExpr termino() :
{
  RegistroExpr reg1 = null;
  RegistroExpr reg2;
  RegistroOp op;
}
{
  try {
    reg1 = factor()
    (
      op = operador_multiplicativo()
      reg2 = factor()
      {
        if (op != null) {
          reg1 = RegistroExpr.operar(op, reg1, reg2);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un término");
  }
  {
    // Generación de código
    reg1.sustituirConstante();
    
    return reg1;
  }
}
/*
 * operador_multiplicativo	::=	( <tPRODUCTO> | <tDIVISION> | <tMOD> | <tAND> )
 */
RegistroOp operador_multiplicativo() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
    t = <tPRODUCTO> { op = new RegistroOp(t, RegistroOp.Operador.PRODUCTO); }
  | t = <tDIVISION> { op = new RegistroOp(t, RegistroOp.Operador.DIVISION); }
  | t = <tMOD>      { op = new RegistroOp(t, RegistroOp.Operador.MOD); }
  | t = <tDIV>      { op = new RegistroOp(t, RegistroOp.Operador.DIV); }
  | t = <tAND>      { op = new RegistroOp(t, RegistroOp.Operador.AND); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador multiplicativo: '*', '/', 'MOD', 'AND'");
  }
  {
    return op;
  }
}
/*
 * factor	::=	( <tMENOS> factor
 *                  | <tMAS> factor
 *                  |  <tNOT> factor
 *					| parentesis_izq expresion parentesis_der
 *					| <tENTACAR> parentesis_izq expresion parentesis_der
 *					| <tCARAENT> parentesis_izq expresion parentesis_der
 *					| identificador | <tCONSTENTERA> | <tCONSTCHAR>
 *					| <tCONSTCAD> | <tTRUE> | <tFALSE> )
 */
RegistroExpr factor() :
{
  Token t = null;
  Simbolo s;
  RegistroExpr indice = null;

  RegistroExpr reg = new RegistroExpr();
  reg.setTipoDesc();
}
{
  try {
    t = <tMENOS> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
        reg.setTipoEnt();
      }
      else if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      else {
        if (reg.esEnt() && reg.getValorEnt() != null) {
          reg.setValorEnt(-reg.getValorEnt());
        }

        // Generacion código
        reg.getListaInstr().addMenosUnario();
      }
      reg.setAsignable(false);
    }
 |  t = <tMAS> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
        reg.setTipoEnt();
      }
      else if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      reg.setAsignable(false);

      // Generación código. No se añade código
    }
  | t = <tNOT> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
      }
      else if (!reg.esBool() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba booleano", t);
        reg.setTipoBool();
      }
      else {
        if (reg.esBool() && reg.getValorBool() != null) {
          reg.setValorBool(!reg.getValorBool());
        }

	    // Generacion código
	    reg.getListaInstr().addNegacionUnaria();
      }
	  reg.setAsignable(false);
    }
  | parentesis_izq() reg = expresion() parentesis_der()
    {
     // No se realiza ninguna comprobación adicional

     // Generación código. No se añade código
    }
  | t = <tENTACAR> parentesis_izq() reg = expresion() parentesis_der()
 	{
 	  if (reg.esVector() || !reg.esEnt() && !reg.esDesc()) {
 	    ErrorSemantico.deteccion("La expresión no se puede convertir en un carácter válido", t);
 	    reg.setVector(false);
 	  }
 	  else if (reg.esEnt() && reg.getValorEnt() != null) {
 	    Integer carNum = reg.getValorEnt();
 	    if (carNum < 0 || carNum > 256) {
 	      ErrorSemantico.deteccion("La expresión no produce un entero ASCII válido", t);
 	    }
 	    else {
 	      reg.setValorChar((char)carNum.intValue());
 	    }
 	  }
 	  reg.setTipoChar();
 	  reg.setAsignable(false);

 	  // Generación código. No se añade código
 	  // La representación interna de caracteres y enteros en la máquina P es la misma
	}
  | t = <tCARAENT> parentesis_izq() reg = expresion() parentesis_der()
    {
      if (reg.esVector() || !reg.esChar() && !reg.esDesc()) {
        ErrorSemantico.deteccion("La expresión no se puede convertir en un entero válido", t);
        reg.setVector(false);
      }
      else if (reg.esChar() && reg.getValorChar() != null) {
        Character car = reg.getValorChar();
        if (Character.isWhitespace(car)) {
          reg.setValorEnt(0);
        }
        else {
          // El caracter es ASCII, si no se habría producido un error léxico
       	  reg.setValorEnt((int) t.image.charAt(0));
       }
     }
     reg.setTipoEnt();
     reg.setAsignable(false);

      // Generación código. No se añade código.
      // La representación interna de caracteres y enteros en la máquina P es la misma.
    }
  | t = identificador() ( corchete_izq() indice = expresion() corchete_der() )?
    {
      if (t != null) {
          try {

              System.out.println("Encontrado identificador en expresión " + t.image);
              
              // puede ser una variable simple o un vector
              
              s = tabla_simbolos.buscar_simbolo(t.image);

              System.out.println("El tipo del identificador es " + s.getTipo());

              if (s.ES_ACCION()) {
                  ErrorSemantico.deteccion("No se puede utilizar una acción dentro de una expresión", t);
                  reg.setTipoDesc();
              }
              else if (s.ES_PROGRAMA()) {
                  ErrorSemantico.deteccion("No se puede utilizar un programa dentro de una expresión", t);
                  reg.setTipoDesc();
              }
              else if (!(s.ES_VARIABLE() || s.ES_PARAMETRO())) {
                  System.out.println("El identificador es desconocido");
                  reg.setTipoDesc();
              }
              else {
                  // El símbolo es variable o parametro

                  // if (s.getNivel() == generacion_codigo.getNivel() && !s.INICIALIZADO()) {
                  //  Aviso.deteccion("El símbolo podría no estar inicializado", t);
                  //}

                  if (s.ES_VARIABLE()) {
                      reg.setTipo(s.getVariable());
                      reg.setAsignable(true);
                  }
                  else if (s.ES_PARAMETRO()) {
                      reg.setTipo(s.getVariable());
                      if (s.ES_VALOR()) {
                          reg.setParVal();
                      }
                      else if (s.ES_REFERENCIA()) {
                          reg.setParRef();
                          reg.setAsignable(true);
                      }
                  }

				  System.err.println("Llegado");
				  
                  // Vectores
                  if (s.ES_VECTOR()) {
                      if (indice == null) {
                          System.err.println("Vector completo: " + s.getNombre() + " " + s.getLongitud());

                          // Vector completo
                          reg.setVector(true);
                          reg.setLongitud(s.getLongitud());

                          System.err.println("Registro: " + reg.getTipo() + " " + reg.esVector() + " " + reg.getLongitud());
                      }
                      else {
                          // Acceso a una componente del vector
                          System.err.println("Acceso a componente de vector: " + s.getNombre() + " " + s.getLongitud() + " " + indice.getValorEnt());

                          // Comprobar tipo
                          if (!indice.esDesc() && !indice.esEnt()) {
                              ErrorSemantico.deteccion("La expresión para acceder a una componente del vector debe ser entera", t);
                          }
                          else if (indice.esEnt() && indice.getValorEnt() != null) {
                              // Comprobar overflow/underflow
                              if (indice.getValorEnt() < 0) {
                                  Aviso.deteccion(new UnderflowException(), t);
                              }
                              else if (indice.getValorEnt() > (s.getLongitud() - 1)) {
                                  Aviso.deteccion(new OverflowException(), t);
                              }
                          }
                      }
                  }
              }
              
              // Generación de código
              if (s.ES_VECTOR() && indice  == null) {
                  reg.getListaInstr().addGetDireccion(s, generacion_codigo.getNivel(), null);
              }
              else {
                  reg.getListaInstr().addGetValor(s, generacion_codigo.getNivel(), indice);
              }
              reg.setSimbolo(s);
        }
        catch (SimboloNoEncontradoException e) {
          ErrorSemantico.deteccion(e, t);
          reg.setTipoDesc();
        }
      }
    }
  | t = <tCONSTENTERA>
    {
      reg = new RegistroExpr();
      reg.setTipoEnt();
      reg.setValorEnt(Integer.parseInt(t.image));

	  // Generación de código
      reg.getListaInstr().addConstEnt(Integer.parseInt(t.image));
    }
  | t = <tCONSTCHAR>
    {
      reg = new RegistroExpr();
      reg.setTipoChar();
	  String c = t.image;
      // Eliminar el primer y último caracteres, que serán "
      c = c.substring(1);
      c = c.substring(0, c.length() - 1);
      reg.setValorChar(c.charAt(0));

      // Generación de código
      reg.getListaInstr().addConstChar(c.charAt(0));
    }
  | <tTRUE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(true);

	  // Generación de código
      reg.getListaInstr().addConstBool(true);
    }
  | <tFALSE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(false);

      // Generación de código
      reg.getListaInstr().addConstBool(false);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un factor");
  }
  {
     return reg;
  }
}

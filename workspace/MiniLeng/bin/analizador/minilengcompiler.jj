/*********************************************************************************
 * Especificación JavaCC para el lenguaje MiniLeng (Procesadores de Lenguajes)
 *
 * Fichero:    minilengcompiler.jj
 * Autor:      Fernando Peña (NIA: 756012)
 * Fecha:      29/03/2020
 * Versión:    v2.2
 * Asignatura: Procesadores de Lenguajes, curso 2019-2020
 **********************************************************************************/
options {
  static = true;
  ignore_case = true;
  // debug_parser = true;
}

PARSER_BEGIN(minilengcompiler)

package analizador;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.ArrayList;

import analizador.TokenMgrError;
import analizador.minilengcompilerTokenManager;
import analizador.SimpleCharStream;

import lib.lexico.TablaOcurrencias;
import lib.lexico.ErrorLexico;
import lib.sintactico.ErrorSintactico;
import lib.sintactico.PanicMode;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.*;
import lib.semantico.TablaSimbolos;
import lib.semantico.SimboloYaDeclaradoException;
import lib.semantico.ErrorSemantico;
import lib.semantico.RegistroExpr;

public class minilengcompiler {

  	private static final String version = "2.2";
  	private static final String fecha_version = "abril de 2020";
  	private static final String fecha_compilado = "10-04-2020";


	protected static Boolean verbose_mode = false;
	protected static Boolean panic_mode = false;
	protected static Boolean show_tokens = false;

	private static Boolean compilado_sin_errores = true;
	private static Boolean entrado_en_panic = false;

	private static TablaSimbolos tabla_simbolos;
	private static int nivel;
	private static int dir;


	private static void help() {
		System.out.println("Uso: minilengcompiler [opciones] fichero\n");
      	System.out.println("Opciones:");
      	System.out.println("  -v, --verbose  Mostrar un resumen de los símbolos utilizados en el programa");
      	System.out.println("  -p, --panic	 Compila con panic mode");
      	System.out.println("  -t, --tokens   Muestra los tokens que se van reconociendo");
      	System.out.println("  -h, --help	 Imprimir ayuda (esta pantalla) y salir");
      	System.out.println("  --version      Imprimir información de la versión y salir");

      	System.exit(0);
    }

    private static void version() {
		System.out.println("  Compilador de MiniLeng Versión " + version + "    Compilado el " + fecha_compilado);
		System.out.println("");
		System.out.println("    Prácticas de la asignatura: Procesadores de Lenguajes");
		System.out.println("      Curso 2019-2020");
		System.out.println("      Universidad de Zaragoza");
		System.out.println("");
		System.out.println("  Programado con JavaCC en Eclipse 2019-12");
		System.out.println("  JavaCC Eclipse Plug-in 1.5.33");

      	System.exit(0);
    }

	public static void main(String args []) throws ParseException {
		System.out.println("Compilador de MiniLeng -- v" + version + " (" + fecha_version + ")");
    	System.out.println("Autor: Fernando Peña Bes (NIA: 756012)\n");

		// Entrada al programa
    	InputStream stream = System.in;
    	String fichero_entrada = null;


    	if (args.length == 0) {
    	  	// Compilador llamado sin argumentos
    	}
    	else if (args[0].equals("-h") || args[0].equals("--help")) {
    	  	// Mostrar ayuda y salir
    	  	help();
  		}
  		else if (args[0].equals("--version")) {
    	  	// Mostrar version y salir
    	  	version();
  		}
  		else {
  			// Leer los argumentos.
  			// Va leyendo hasta que encuentra uno que no empieza por '-',
  			// ese argumento se considera como fichero de entrada
  			for (int i = 0; i < args.length; i++) {
  			    switch(args[i]) {
  			        case "-h":
  			        case "--help":
  			        case "--version":
  			            // Ignorar si aparece ayuda o versión de nuevo
  			        	break;

  			      	case "-v":
  			      	case "--verbose":
  			      		// Activar modo verboso
  			      		verbose_mode = true;
  			      		break;

  			      	case "-p":
  			      	case "--panic":
  			      		// Activar modo pánico
  			      		panic_mode = true;
  			      		break;

  			        case "-t":
  			        case "--tokens":
  			        	// Mostrar tokens conforme se reconocen
  			        	show_tokens = true;
  			        	break;

					default:
						if (args[i].charAt(0) == '-') {
							System.err.println("MiniLeng: Opción inválida <" + args[i] + ">\n");
							help();
						}
						else {
						  	fichero_entrada = args[i];
						}
						break;
  			    }
  			}
 		}


		if (fichero_entrada != null) {
		  	// Lectura del fichero del usuario.

			// Si el fichero no terminal en .ml, error
			if (!fichero_entrada.endsWith(".ml")) {
        		System.err.println("MiniLeng: El fichero a compilar tiene que tener extensión .ml");
        		System.err.println("          Fichero introducido: '" + fichero_entrada + "'");
        		System.exit(0);
			}

			// Ejecutar el compilador con los fichero introducidos
			System.out.println("MiniLeng: Leyendo el fichero " + fichero_entrada + " ...");
      		try {
        		// parser = new minilengcompiler(new FileInputStream(args[0]));
        		stream = new FileInputStream(fichero_entrada);
      		}
      		catch (FileNotFoundException e) {
        		System.err.println("MiniLeng: No se ha encontrado el fichero '" + fichero_entrada + "'");
        		System.exit(0);
      		}
		}
		else {
  			help();
		}


		// Ejecución del compilador
        try {
    		minilengcompiler parser = new minilengcompiler(stream);
    		tabla_simbolos = new TablaSimbolos();
    		minilengcompiler.programa();
        }
        catch (Exception e) {
            // System.out.println(e.getMessage());
           	throw e;
        }
        catch (Error e) {
		  	// Detectado error léxico
			SimpleCharStream entrada = minilengcompilerTokenManager.input_stream;
			String error;

			try {
				error = Character.toString(entrada.readChar());
			}
			catch (java.io.IOException fin_fichero) {
		  		error = "<EOF>";
			}

			ErrorLexico.deteccion(entrada.getEndLine(), entrada.getEndColumn(), error, TokenMgrError.addEscapes(error));
		}

		// Imprimir resultados de la compilación
		resultadosCompilacion();
    }

	static void resultadosCompilacion() {
	  	System.out.println("");

	  	// Mostrar contadores de errores
		if (ErrorLexico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores léxicos: " + ErrorLexico.getContadorErrores());
		}

		if (ErrorSintactico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores sintácticos: " + ErrorSintactico.getContadorErrores());
		}

	    if (PanicMode.getContadorErrores() > 0) {
		  	entrado_en_panic = true;
		  	System.out.println("Veces activado panic mode: " + PanicMode.getContadorErrores());
		}

		// Resultados compilacion
		if (!compilado_sin_errores) {
		  	System.out.println("No se ha podido compilar el programa.");
		}
		else if (entrado_en_panic) {
		  	System.out.println("Se ha activado el panic mode durante la compilación. Corrige los errores y vuelve a compilar.");
		}
		else {
		  	System.out.println("Compilado sin errores!");
		}
	}}PARSER_END(minilengcompiler)



/**** Análisis léxico ****/

TOKEN_MGR_DECLS : {
  // Crear e inicializar tabla de ocurrencias
  static TablaOcurrencias tabla_ocurrencias = new TablaOcurrencias(minilengcompiler.show_tokens);
}
SKIP : {  " "| "\r"| "\t"| "\n"
| < "%"~["%"] > : COMENTARIO
| "%%"          : MULTICOMENTARIO}

// Ignorar comentarios en la entrada
< COMENTARIO > SKIP : {
  "\n" : DEFAULT
}

<COMENTARIO> MORE : {
   < ~[] >
}

<MULTICOMENTARIO> SKIP : {
  "%%" : DEFAULT
}

<MULTICOMENTARIO> MORE : {
   < ~[] >
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPROGRAMA);
  }
| < tVAR : "var" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAR);
  }
| < tPRINCIPIO : "principio" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPRINCIPIO);
  }
| < tFIN : "fin" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFIN);
  }
| < tSI : "si" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI);
  }
| < tENT : "ent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENT);

  }
| < tSI_NO : "si_no" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI_NO);
  }
| < tFSI : "fsi" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFSI);
  }
| < tMQ : "mq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tMQ);
  }
| < tFMQ : "fmq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFMQ);
  }
| < tESCRIBIR : "escribir" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tESCRIBIR);
  }
| < tLEER : "leer" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tLEER);
  }

  // Funciones predefinidas
| < tENTACAR : "entacar" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENTACAR);
  }
| < tCARAENT : "caraent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tCARAENT);
  }

  // Funciones
| < tACCION : "accion" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tACCION);
  }
| < tVAL : "val" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAL);
  }
|  < tREF : "ref" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tREF);
  }
}


TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tENTERO);
  }
| < tBOOLEANO : "booleano" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tBOOLEANO);
  }
| < tCARACTER : "caracter" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tCARACTER);
  }
}


TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_IZQ);
  }
| < tLLAVE_DER : "}" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_DER);
  }
| < tPARENTESIS_IZQ : "(" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_IZQ);
  }
| < tPARENTESIS_DER : ")" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_DER);
  }
}


TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tOPAS);
  }

| < tFIN_SENTENCIA : ";" > {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tFIN_SENTENCIA);
  }
| < tSEP_VARIABLE : "," > {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tSEP_VARIABLE);
  }

  // Aritméticos
| < tMAS : "+" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMAS);
  }
| < tMENOS : "-" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMENOS);
  }
| < tPRODUCTO : "*" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tPRODUCTO);
  }
| < tDIVISION : "/" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIVISION);
  }
| < tMOD : "mod" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMOD);
  }
| < tDIV : "div" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIV);
  }

  // Lógicos
| < tAND : "and" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tAND);
  }
| < tOR : "or" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tOR);
  }
| < tNOT : "not" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNOT);
  }
| < tMAYOR : ">" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAYOR);
  }
| < tMENOR : "<" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMENOR);
  }
| < tIGUAL : "=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tIGUAL);
  }
| < tMAI : ">=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAI);
  }
| < tMEI : "<=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMEI);
  }
| < tNI : "<>" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNI);
  }
}


TOKEN : /* VALORES */
{
  < #DIGITO : [ "0"-"9" ] >
| < #LETRA : [ "a"-"z" ] >

  // Booleanos
| < tTRUE : "true" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tTRUE, "True");
  }
| < tFALSE : "false" >
  {
     tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tFALSE, "False");
  }

  // Identificadores
| < tIDENTIFICADOR : (< LETRA > | "_"(< LETRA > | < DIGITO >))(("_")?(< LETRA > | < DIGITO >))* >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tIDENTIFICADOR, matchedToken.image);
  }

  // Enteros
  // | < tCONSTENTERA : ("+" | "-")?(["0"-"9"])+ >
| < tCONSTENTERA : (["0"-"9"])+ >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTENTERA, matchedToken.image);
  }

   // Caracteres
| < tCONSTCHAR : "\""(~["\""])?"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCHAR, matchedToken.image);
  }

  // Cadena de caracteres
| < tCONSTCAD : "\""(~["\""])*"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCAD, matchedToken.image);
  }
}



/**** Análisis sintáctico ****/

// Inicio programa

/*
 * programa	::=	<tPROGRAMA> identificador fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias <EOF>
 */
int programa() :
{
  int nivel = 0;
  tabla_simbolos.inicializar_tabla();

  Token t;
}
{
  try {
  	<tPROGRAMA> 
  	t = identificador()
  	{
  	  	System.out.println("Leído programa " + t.image);
  		tabla_simbolos.introducir_programa(t.image, 0);
  	}
  	
  	fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias() < EOF >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "La declaración del programa es incorrecta");
  }

  {
      System.out.println("Antes de cerrar programa. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el programa y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  tabla_simbolos.eliminar_programa();

  	  System.out.println("Después de cerrar programa");
  	  tabla_simbolos.imprimirTabla();
  }

  {
    if (verbose_mode) {
      token_source.tabla_ocurrencias.imprimirTabla();
    }
    return 0;
  }

}


// Declaraciones de separadores y limitadores de bloque

void fin_sentencia() :
{}
{
  try {
    < tFIN_SENTENCIA >
  }
  catch (ParseException e) {
    // Si el modo pánico está activado, descartar entrada hasta el siguiente ;
    if (panic_mode) {
      PanicMode.iniciar(e, "Se esperaba ';'", tFIN_SENTENCIA, ";");
    }
    else {
      ErrorSintactico.deteccion(e, "Se esperaba ';'");
    }
  }
}
void sep_variable() :
{}
{
  try {
    < tSEP_VARIABLE >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ','");
  }
}

void parentesis_izq() :
{}
{
  try {
    < tPARENTESIS_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta paréntesis de cierre: ')'");
  }
}
void parentesis_der() :
{}
{
  try {
    < tPARENTESIS_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '('");
  }
}

void principio() :
{}
{
  try {
    < tPRINCIPIO >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de principio de bloque: 'principio'");
  }
}
void fin() :
{}
{
  try {
    < tFIN >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador fin de bloque: 'fin'");
  }
}


// Sintaxis del lenguaje

Token identificador() :
{
  Token t;
}
{
  try {
    t = < tIDENTIFICADOR >
    {
        return t;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un identificador");
  }
}


/*
 * declaracion_variables ::= ( declaracion fin_sentencia )*
 */
void declaracion_variables() :
{}
{
  try {
    {
      System.out.println("Entrado en declaracion de variables");
    }
  	( declaracion() fin_sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion ::= tipo_variables identificadores
 */
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores;
}
{
  try {
  	tipo = tipo_variables()
  	listaIdentificadores = identificadores()
  	{
  	  System.out.println("Entrado en declaracion");
  	}
  	{
  	  for (Token id : listaIdentificadores) {
  	    try {
  	      System.out.println("Se va a introducir una variable: " + id.image);
  	      tabla_simbolos.introducir_variable(id.image, tipo, nivel, dir);
  	      dir++;
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      ErrorSemantico.deteccion(e, id);
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de variables");
  }
}
/*
 * tipo_variables	::=	( <tENTERO> | <tCARACTER> | <tBOOLEANO> )
 */
Tipo_variable tipo_variables() :
{}
{
  try {
  	<tENTERO> { return Tipo_variable.ENTERO; }
  | <tCARACTER> { return Tipo_variable.CHAR; }
  | <tBOOLEANO> { return Tipo_variable.CADENA; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de dato");
  }
}
/*
 * identificadores	::=	identificador ( sep_variable identificador )*
 */
ArrayList<Token> identificadores() :
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t; 
}
{
  try {
  	t = identificador()
  	{
  	  System.out.println("Leido el identificador: " + t.image);
  	  tokens.add(t);
  	}
  	
  	(
  	  sep_variable()
  	  t = identificador()
  	  {
  	    System.out.println("Leido el identificador: " + t.image);
  	    tokens.add(t);
  	  }
  	)*
  	{
  	  return tokens;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba uno o varios identificadores");
  }
}

/*
 * declaracion_acciones	::=	( declaracion_accion )*
 */
void declaracion_acciones() :
{}
{
  try {
  	( declaracion_accion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion_accion	::=	cabecera_accion fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias
 */
void declaracion_accion() :
{}
{
  try {
  	cabecera_accion() fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias()

  	{

  	  System.out.println("Antes de cerrar accion. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el bloque y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_parametros(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  nivel--;

  	  System.out.println("Después de cerrar acción");
  	  tabla_simbolos.imprimirTabla();
  	  
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de acción");
  }
}
/*
 * cabecera_accion	::=	<tACCION> identificador parametros_formales
 */
void cabecera_accion() :
{
  Token t;
  Simbolo s = new Simbolo();
  boolean ok = false;
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
  	<tACCION>
  	
  	t = identificador()
  	{
  	  // Procesar símbolo del identificador
  	  try {
  	    System.out.println("Se va a introducir una accion " + t.image);
  	    s = tabla_simbolos.introducir_accion(t.image, nivel, dir);
  	    ok = true;
  	  }
  	  catch (SimboloYaDeclaradoException e) {
  	    ErrorSemantico.deteccion(e, t);
  	  }
  	  nivel++;
  	}
  	
  	parametros = parametros_formales(t.image)
  	{
  	  if (ok) {
  	    s.setListaParametros(parametros);
  	  } 
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta la cabecera de la acción");
  }
}

/*
 * parametros_formales	::=	( parentesis_izq ( lista_parametros )? parentesis_der )?
 */
ArrayList<Simbolo> parametros_formales(String nombreAccion) :
{
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
	( parentesis_izq() ( parametros = lista_parametros() )? parentesis_der() )?
	{
	  return parametros;
	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * lista_parametros	::=	parametros ( fin_sentencia parametros )*
 */
ArrayList<Simbolo> lista_parametros() :
{
  ArrayList<Simbolo> parametros;
  ArrayList<Simbolo> parametrosAux;
}
{
  try {
  	parametros = parametros()
  	(
  	  fin_sentencia()
  	  parametrosAux = parametros()
  	  {
  	    parametros.addAll(parametrosAux);
  	  }
  	)*
  	{
  	  return parametros;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban uno o varios parámetros");
  }
}
/*
 * parametros	::=	clase_parametros tipo_variables identificadores
 */
ArrayList<Simbolo> parametros() :
{
  Clase_parametro clase;
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores = new ArrayList<Token>();

  Simbolo s;
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
  	clase = clase_parametros()
  	tipo = tipo_variables()
  	listaIdentificadores = identificadores()
  	{
  	  for (Token id : listaIdentificadores) {
  	    try {
  	      System.out.println("Se va a introducir un parametro: " + id.image + " " + tipo + " " + clase);
  	      s = tabla_simbolos.introducir_parametro(id.image, tipo, clase, nivel, dir);
  	      parametros.add(s);
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      // Si el símbolo está ya declarado, se introduce como un parámetro anónimo
  	      // en la lista de parametros para poder hacer la comprobación de signatura
  	      // al llamar a la función, pero no se mete en la tabla de simbolos. 
  	      ErrorSemantico.deteccion(e, id);
  	      s = new Simbolo();
  	      s.introducir_parametro("__anonymus", tipo, clase, nivel, dir);
  	      parametros.add(s);
  	    }
  	  }
  	  return parametros;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un parámetro");
  }
}
/*
 * clase_parametros	::=	( <tVAL> | <tREF> )
 */
Clase_parametro clase_parametros() :
{}
{
  try {
  	<tVAL> { return Clase_parametro.VAL; }
    | <tREF> { return Clase_parametro.REF; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de parametro");
  }
}


/*
 * bloque_sentencias	::=	principio lista_sentencias fin
 */
void bloque_sentencias() :
{}
{
  try {
    principio() lista_sentencias() fin()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un bloque se sentencias");
  }
}
/*
 * lista_sentencias	::=	sentencia ( sentencia )*
 */
void lista_sentencias() :
{}
{
  try {
    sentencia() ( sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban una o más sentencias");
  }
}
/*
 * sentencia	::=	( leer | escribir | identificacion | seleccion | mientras_que )
 */
void sentencia() :
{}
{
  try {
    leer()
  | escribir()
  | identificacion()
  | seleccion()
  | mientras_que()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una sentencia");
  }
}

/*
 * leer	::=	<tLEER> parentesis_izq lista_asignables parentesis_der fin_sentencia
 */
void leer() :
{}
{
  try {
  	<tLEER> parentesis_izq() lista_asignables() parentesis_der() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia leer");
  }
}
/*
 * lista_asignables	::=	identificadores
 */
void lista_asignables() :
{}
{
  try {
  	identificadores()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de asignables");
  }
}
/*
 * escribir	::=	<tESCRIBIR> parentesis_izq lista_escribibles parentesis_der fin_sentencia
 */
void escribir() :
{}
{
  try {
  	<tESCRIBIR> parentesis_izq() lista_escribibles() parentesis_der()  fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia escribir");
  }
}
/*
 * lista_escribibles	::=	lista_expresiones
 */
void lista_escribibles() :
{}
{
  try {
  	lista_expresiones()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de escribibles");
  }
}

/*
 * asignacion	::=	<tOPAS> expresion fin_sentencia
 */
void asignacion() :
{}
{
  try {
    <tOPAS> expresion() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación");
  }
}

/*
 * identificacion	::=	identificador ( ( argumentos )? fin_sentencia | asignacion )
 */
void identificacion() :
{}
{
  try {
  	identificador() ( ( argumentos() )? fin_sentencia() | asignacion() )
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación o una acción");
  }
}

/*
 * mientras_que	::=	<tMQ> expresion lista_sentencias <tFMQ>
 */
void mientras_que() :
{}
{
  <tMQ>
  expresion()
  lista_sentencias()
  try {
  	<tFMQ>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura MQ: 'FMQ'");
  }

}

/*
 * seleccion	::=	<tSI> expresion <tENT> lista_sentencias ( <tSI_NO> lista_sentencias )* <tFSI>
 */
void seleccion() :
{}
{
  <tSI>
  expresion()
  try {
  	<tENT>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el token 'ENT'");
  }
  lista_sentencias()
  ( <tSI_NO> lista_sentencias() )*
  try {
  	<tFSI>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura SI: 'FSI'");
  }
}

/*
 * argumentos	::=	parentesis_izq ( lista_expresiones )? parentesis_der
 */
void argumentos() :
{}
{
  try {
  	parentesis_izq() ( lista_expresiones() )? parentesis_der()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de argumentos");
  }
}

/*
 * lista_expresiones	::=	expresion ( sep_variable expresion )*
 */
void lista_expresiones() :
{}
{
  try {
    expresion() ( sep_variable() expresion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de expresiones");
  }
}

/*
 * expresion	::=	expresion_simple ( operador_relacional expresion_simple )?
 */
void expresion() :
{}
{
  try {
  	expresion_simple()  ( operador_relacional()  expresion_simple() )?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión");
  }
}
/*
 * operador_relacional	::=	( <tIGUAL> | <tMENOR> | <tMAYOR> | <tMAI> | <tMEI> | <tNI> )
 */
void operador_relacional() :
{}
{
  try {
  	<tIGUAL>
  | <tMENOR>
  | <tMAYOR>
  | <tMAI>
  | <tMEI>
  | <tNI>
 }
 catch (ParseException e) {
   ErrorSintactico.deteccion(e, "Se esperaba un operador relacional: '=', ' >', '<', '<=', '>=', o '!='");
 }
}
/*
 * expresion_simple	::=	( <tMAS> | <tMENOS> )? termino ( operador_aditivo termino )*
 */
void expresion_simple() :
{}
{
  try {
    termino() ( operador_aditivo() termino() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión simple");
  }
}
/*
 * operador_aditivo	::=	( <tMAS> | <tMENOS> | <tOR> )
 */
void operador_aditivo() :
{}
{
  try {
    <tMAS>
  | <tMENOS>
  | <tOR>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador aditivo: '+', '-', o 'OR'");
  }
}
/*
 * termino	::=	factor ( operador_multiplicativo factor )*
 */
void termino() :
{}
{
  try {
    factor() ( operador_multiplicativo() factor() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un término");
  }
}
/*
 * operador_multiplicativo	::=	( <tPRODUCTO> | <tDIVISION> | <tMOD> | <tAND> )
 */
void operador_multiplicativo() :
{}
{
  try {
    <tPRODUCTO>
  | <tDIVISION>
  | <tMOD>
  | <tDIV>
  | <tAND>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador multiplicativo: '*', '/', 'MOD', 'AND'");
  }
}
/*
 * factor	::=	( <tNOT> factor
 *					| parentesis_izq expresion parentesis_der
 *					| <tENTACAR> parentesis_izq expresion parentesis_der
 *					| <tCARAENT> parentesis_izq expresion parentesis_der
 *					| identificador | <tCONSTENTERA> | <tCONSTCHAR>
 *					| <tCONSTCAD> | <tTRUE> | <tFALSE> )
 */
RegistroExpr factor() :
{
  Token t = null;
  RegistroExpr expr = new RegistroExpr();
}
{
  try {
    t = <tMENOS> expr = factor()
    {
      if (!expr.esDesc() && !expr.esEnt()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
      }
      // TODO
      return expr;
    }
  | t = <tNOT> expr = factor()
    {
      if (!expr.esDesc() && !expr.esBool()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba booleano", t);
      }
      // TODO
      return expr;
    }
  | parentesis_izq() expresion() parentesis_der()
  | <tENTACAR> parentesis_izq() expresion() parentesis_der()
  | <tCARAENT> parentesis_izq() expresion() parentesis_der()
  | identificador()
  | t = <tCONSTENTERA>
    {
      expr = new RegistroExpr();
      expr.setTipoEnt();
      expr.setValorEnt(Integer.parseInt(t.image));
    }
  | t = <tCONSTCHAR>
    {
      expr = new RegistroExpr();
      expr.setTipoChar();
      expr.setValorChar(t.image.charAt(0));
    }
  | <tCONSTCAD>
    {
      expr = new RegistroExpr();
      expr.setTipoCad();
      expr.setValorCad(t.image);
    }
  | <tTRUE>
    {
      expr = new RegistroExpr();
      expr.setTipoBool();
      expr.setValorBool(true);
    }
  | <tFALSE>
    {
      expr = new RegistroExpr();
      expr.setTipoBool();
      expr.setValorBool(false);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un factor");
  }
}

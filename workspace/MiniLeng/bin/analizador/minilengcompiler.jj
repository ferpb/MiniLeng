/*********************************************************************************
 * Especificación JavaCC para el lenguaje MiniLeng (Procesadores de Lenguajes)
 *
 * Fichero:    minilengcompiler.jj
 * Autor:      Fernando Peña (NIA: 756012)
 * Fecha:      29/03/2020
 * Versión:    v2.2
 * Asignatura: Procesadores de Lenguajes, curso 2019-2020
 **********************************************************************************/
options {
  static = true;
  ignore_case = true;
  // debug_parser = true;
}

PARSER_BEGIN(minilengcompiler)

package analizador;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.ArrayList;

import analizador.TokenMgrError;
import analizador.minilengcompilerTokenManager;
import analizador.SimpleCharStream;

import lib.lexico.TablaOcurrencias;
import lib.lexico.ErrorLexico;
import lib.sintactico.ErrorSintactico;
import lib.sintactico.PanicMode;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.*;
import lib.semantico.TablaSimbolos;
import lib.semantico.SimboloYaDeclaradoException;
import lib.semantico.SimboloNoEncontradoException;
import lib.semantico.InvocacionAccionException;
import lib.semantico.ErrorSemantico;
import lib.semantico.RegistroExpr;
import lib.semantico.RegistroOp;
import lib.aviso.Aviso;


public class minilengcompiler {

  	private static final String version = "2.2";
  	private static final String fecha_version = "abril de 2020";
  	private static final String fecha_compilado = "10-04-2020";


	protected static Boolean verbose_mode = false;
	protected static Boolean panic_mode = false;
	protected static Boolean show_tokens = false;

	private static Boolean compilado_sin_errores = true;
	private static Boolean entrado_en_panic = false;

	private static TablaSimbolos tabla_simbolos;
	private static int nivel;
	private static int dir;


	private static void help() {
		System.out.println("Uso: minilengcompiler [opciones] fichero\n");
      	System.out.println("Opciones:");
      	System.out.println("  -v, --verbose  Mostrar un resumen de los símbolos utilizados en el programa");
      	System.out.println("  -p, --panic	 Compila con panic mode");
      	System.out.println("  -t, --tokens   Muestra los tokens que se van reconociendo");
      	System.out.println("  -h, --help	 Imprimir ayuda (esta pantalla) y salir");
      	System.out.println("  --version      Imprimir información de la versión y salir");

      	System.exit(0);
    }

    private static void version() {
		System.out.println("  Compilador de MiniLeng Versión " + version + "    Compilado el " + fecha_compilado);
		System.out.println("");
		System.out.println("    Prácticas de la asignatura: Procesadores de Lenguajes");
		System.out.println("      Curso 2019-2020");
		System.out.println("      Universidad de Zaragoza");
		System.out.println("");
		System.out.println("  Programado con JavaCC en Eclipse 2019-12");
		System.out.println("  JavaCC Eclipse Plug-in 1.5.33");

      	System.exit(0);
    }

	public static void main(String args []) throws ParseException {
		System.out.println("Compilador de MiniLeng -- v" + version + " (" + fecha_version + ")");
    	System.out.println("Autor: Fernando Peña Bes (NIA: 756012)\n");

		// Entrada al programa
    	InputStream stream = System.in;
    	String fichero_entrada = null;


    	if (args.length == 0) {
    	  	// Compilador llamado sin argumentos
    	}
    	else if (args[0].equals("-h") || args[0].equals("--help")) {
    	  	// Mostrar ayuda y salir
    	  	help();
  		}
  		else if (args[0].equals("--version")) {
    	  	// Mostrar version y salir
    	  	version();
  		}
  		else {
  			// Leer los argumentos.
  			// Va leyendo hasta que encuentra uno que no empieza por '-',
  			// ese argumento se considera como fichero de entrada
  			for (int i = 0; i < args.length; i++) {
  			    switch(args[i]) {
  			        case "-h":
  			        case "--help":
  			        case "--version":
  			            // Ignorar si aparece ayuda o versión de nuevo
  			        	break;

  			      	case "-v":
  			      	case "--verbose":
  			      		// Activar modo verboso
  			      		verbose_mode = true;
  			      		break;

  			      	case "-p":
  			      	case "--panic":
  			      		// Activar modo pánico
  			      		panic_mode = true;
  			      		break;

  			        case "-t":
  			        case "--tokens":
  			        	// Mostrar tokens conforme se reconocen
  			        	show_tokens = true;
  			        	break;

					default:
						if (args[i].charAt(0) == '-') {
							System.err.println("MiniLeng: Opción inválida <" + args[i] + ">\n");
							help();
						}
						else {
						  	fichero_entrada = args[i];
						}
						break;
  			    }
  			}
 		}


		if (fichero_entrada != null) {
		  	// Lectura del fichero del usuario.

			// Si el fichero no terminal en .ml, error
			if (!fichero_entrada.endsWith(".ml")) {
        		System.err.println("MiniLeng: El fichero a compilar tiene que tener extensión .ml");
        		System.err.println("          Fichero introducido: '" + fichero_entrada + "'");
        		System.exit(0);
			}

			// Ejecutar el compilador con los fichero introducidos
			System.out.println("MiniLeng: Leyendo el fichero " + fichero_entrada + " ...");
      		try {
        		// parser = new minilengcompiler(new FileInputStream(args[0]));
        		stream = new FileInputStream(fichero_entrada);
      		}
      		catch (FileNotFoundException e) {
        		System.err.println("MiniLeng: No se ha encontrado el fichero '" + fichero_entrada + "'");
        		System.exit(0);
      		}
		}
		else {
  			help();
		}


		// Ejecución del compilador
        try {
    		minilengcompiler parser = new minilengcompiler(stream);
    		tabla_simbolos = new TablaSimbolos();
    		minilengcompiler.programa();
        }
        catch (Exception e) {
            System.err.println("Error en el compilador");
            System.err.println("Cabeza de lectura: (línea " + token.beginLine + ", columna " + token.beginColumn + ") " + token);
           	throw e;
        }
        catch (Error e) {
		  	// Detectado error léxico
			SimpleCharStream entrada = minilengcompilerTokenManager.input_stream;
			String error;

			try {
				error = Character.toString(entrada.readChar());
			}
			catch (java.io.IOException fin_fichero) {
		  		error = "<EOF>";
			}

			ErrorLexico.deteccion(entrada.getEndLine(), entrada.getEndColumn(), error, TokenMgrError.addEscapes(error));
		}

		// Imprimir resultados de la compilación
		resultadosCompilacion();
    }

	static void resultadosCompilacion() {
	  	System.out.println("");

	  	// Mostrar contadores de errores
		if (ErrorLexico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores léxicos: " + ErrorLexico.getContadorErrores());
		}

		if (ErrorSintactico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores sintácticos: " + ErrorSintactico.getContadorErrores());
		}

		if (ErrorSemantico.getContadorErrores() > 0) {
		  compilado_sin_errores = false;
		  System.out.println("Errores semánticos: " + ErrorSemantico.getContadorErrores());
		}

		if (Aviso.getContadorAvisos() > 0) {
			System.out.println("Avisos: " + Aviso.getContadorAvisos());
		}

	    if (PanicMode.getContadorErrores() > 0) {
		  	entrado_en_panic = true;
		  	System.out.println("Veces activado panic mode: " + PanicMode.getContadorErrores());
		}

		// Resultados compilacion
		if (!compilado_sin_errores) {
		  	System.out.println("No se ha podido compilar el programa.");
		}
		else if (entrado_en_panic) {
		  	System.out.println("Se ha activado el panic mode durante la compilación. Corrige los errores y vuelve a compilar.");
		}
		else {
		  	System.out.println("Compilado sin errores!");
		}
	}}PARSER_END(minilengcompiler)



/**** Análisis léxico ****/

TOKEN_MGR_DECLS : {
  // Crear e inicializar tabla de ocurrencias
  static TablaOcurrencias tabla_ocurrencias = new TablaOcurrencias(minilengcompiler.show_tokens);
}
SKIP : {  " "| "\r"| "\t"| "\n"
| < "%"~["%"] > : COMENTARIO
| "%%"          : MULTICOMENTARIO}

// Ignorar comentarios en la entrada
< COMENTARIO > SKIP : {
  "\n" : DEFAULT
}

<COMENTARIO> MORE : {
   < ~[] >
}

<MULTICOMENTARIO> SKIP : {
  "%%" : DEFAULT
}

<MULTICOMENTARIO> MORE : {
   < ~[] >
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPROGRAMA);
  }
| < tVAR : "var" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAR);
  }
| < tPRINCIPIO : "principio" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPRINCIPIO);
  }
| < tFIN : "fin" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFIN);
  }
| < tSI : "si" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI);
  }
| < tENT : "ent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENT);

  }
| < tSI_NO : "si_no" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI_NO);
  }
| < tFSI : "fsi" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFSI);
  }
| < tMQ : "mq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tMQ);
  }
| < tFMQ : "fmq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFMQ);
  }
| < tESCRIBIR : "escribir" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tESCRIBIR);
  }
| < tLEER : "leer" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tLEER);
  }

  // Funciones predefinidas
| < tENTACAR : "entacar" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENTACAR);
  }
| < tCARAENT : "caraent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tCARAENT);
  }

  // Funciones
| < tACCION : "accion" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tACCION);
  }
| < tVAL : "val" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAL);
  }
|  < tREF : "ref" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tREF);
  }
}


TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tENTERO);
  }
| < tBOOLEANO : "booleano" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tBOOLEANO);
  }
| < tCARACTER : "caracter" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tCARACTER);
  }
}


TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_IZQ);
  }
| < tLLAVE_DER : "}" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_DER);
  }
| < tPARENTESIS_IZQ : "(" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_IZQ);
  }
| < tPARENTESIS_DER : ")" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_DER);
  }
}

TOKEN : /* VECTORES */
{
  < tCORCHETE_IZQ : "[" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_IZQ);
  }
  
| < tCORCHETE_DER : "]" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_DER);
  }
}


TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tOPAS);
  }

| < tFIN_SENTENCIA : ";" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tFIN_SENTENCIA);
  }
| < tSEP_VARIABLE : "," >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tSEP_VARIABLE);
  }

  // Aritméticos
| < tMAS : "+" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMAS);
  }
| < tMENOS : "-" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMENOS);
  }
| < tPRODUCTO : "*" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tPRODUCTO);
  }
| < tDIVISION : "/" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIVISION);
  }
| < tMOD : "mod" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMOD);
  }
| < tDIV : "div" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIV);
  }

  // Lógicos
| < tAND : "and" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tAND);
  }
| < tOR : "or" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tOR);
  }
| < tNOT : "not" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNOT);
  }
| < tMAYOR : ">" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAYOR);
  }
| < tMENOR : "<" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMENOR);
  }
| < tIGUAL : "=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tIGUAL);
  }
| < tMAI : ">=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAI);
  }
| < tMEI : "<=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMEI);
  }
| < tNI : "<>" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNI);
  }
}


TOKEN : /* VALORES */
{
  < #DIGITO : [ "0"-"9" ] >
| < #LETRA : [ "a"-"z" ] >

  // Booleanos
| < tTRUE : "true" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tTRUE, "True");
  }
| < tFALSE : "false" >
  {
     tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tFALSE, "False");
  }

  // Identificadores
| < tIDENTIFICADOR : (< LETRA > | "_"(< LETRA > | < DIGITO >))(("_")?(< LETRA > | < DIGITO >))* >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tIDENTIFICADOR, matchedToken.image);
  }

  // Enteros
  // | < tCONSTENTERA : ("+" | "-")?(["0"-"9"])+ >
| < tCONSTENTERA : (["0"-"9"])+ >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTENTERA, matchedToken.image);
  }

   // Caracteres
| < tCONSTCHAR : "\""(~["\""])?"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCHAR, matchedToken.image);
  }

  // Cadena de caracteres
| < tCONSTCAD : "\""(~["\""])*"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCAD, matchedToken.image);
  }
}



/**** Análisis sintáctico ****/

// Inicio programa

/*
 * programa	::=	<tPROGRAMA> identificador fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias <EOF>
 */
int programa() :
{
  int nivel = 0;
  tabla_simbolos.inicializar_tabla();

  Token t;
}
{
  try {
  	<tPROGRAMA> 
  	t = identificador()
  	{
  	  	System.out.println("Leído programa " + t.image);
  		tabla_simbolos.introducir_programa(t.image, 0);
  	}
  	
  	fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias() < EOF >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "La declaración del programa es incorrecta");
  }

  {
      System.out.println("Antes de cerrar programa. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el programa y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  tabla_simbolos.eliminar_programa();

  	  System.out.println("Después de cerrar programa");
  	  tabla_simbolos.imprimirTabla();
  }

  {
    if (verbose_mode) {
      token_source.tabla_ocurrencias.imprimirTabla();
    }
    return 0;
  }

}


// Declaraciones de separadores y limitadores de bloque

void fin_sentencia() :
{}
{
  try {
    < tFIN_SENTENCIA >
  }
  catch (ParseException e) {
    // Si el modo pánico está activado, descartar entrada hasta el siguiente ;
    if (panic_mode) {
      PanicMode.iniciar(e, "Se esperaba ';'", tFIN_SENTENCIA, ";");
    }
    else {
      ErrorSintactico.deteccion(e, "Se esperaba ';'");
    }
  }
}
void sep_variable() :
{}
{
  try {
    < tSEP_VARIABLE >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ','");
  }
}

void parentesis_izq() :
{}
{
  try {
    < tPARENTESIS_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta paréntesis de cierre: ')'");
  }
}
void parentesis_der() :
{}
{
  try {
    < tPARENTESIS_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '('");
  }
}

void principio() :
{}
{
  try {
    < tPRINCIPIO >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de principio de bloque: 'principio'");
  }
}
void fin() :
{}
{
  try {
    < tFIN >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador fin de bloque: 'fin'");
  }
}


// Sintaxis del lenguaje

Token identificador() :
{
  Token t;
}
{
  try {
    t = < tIDENTIFICADOR >
    {
        return t;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un identificador");
  }
}


/*
 * declaracion_variables ::= ( declaracion fin_sentencia )*
 */
void declaracion_variables() :
{}
{
  try {
    {
      System.out.println("Entrado en declaracion de variables");
    }
  	( declaracion() fin_sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion ::= tipo_variables identificadores
 */
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores;
}
{
  try {
  	tipo = tipo_variables()
  	listaIdentificadores = identificadores()
  	{
  	  System.out.println("Entrado en declaracion");
  	}
  	{
  	  for (Token id : listaIdentificadores) {
  	    try {
  	      System.out.println("Se va a introducir una variable: " + id.image);
  	      tabla_simbolos.introducir_variable(id.image, tipo, nivel, dir);
  	      dir++;
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      ErrorSemantico.deteccion(e, id);
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de variables");
  }
}
/*
 * tipo_variables	::=	( <tENTERO> | <tCARACTER> | <tBOOLEANO> )
 */
Tipo_variable tipo_variables() :
{}
{
  try {
  	<tENTERO> { return Tipo_variable.ENTERO; }
  | <tCARACTER> { return Tipo_variable.CHAR; }
  | <tBOOLEANO> { return Tipo_variable.BOOLEANO; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de dato");
  }
}
/*
 * identificadores	::=	identificador ( sep_variable identificador )*
 */
ArrayList<Token> identificadores() :
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t; 
}
{
  try {
  	t = identificador()
  	{
  	  System.out.println("Leido el identificador: " + t.image);
  	  tokens.add(t);
  	}
  	
  	(
  	  sep_variable()
  	  t = identificador()
  	  {
  	    System.out.println("Leido el identificador: " + t.image);
  	    tokens.add(t);
  	  }
  	)*
  	{
  	  return tokens;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba uno o varios identificadores");
  }
}

/*
 * declaracion_acciones	::=	( declaracion_accion )*
 */
void declaracion_acciones() :
{}
{
  try {
  	( declaracion_accion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion_accion	::=	cabecera_accion fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias
 */
void declaracion_accion() :
{}
{
  try {
  	cabecera_accion() fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias()

  	{

  	  System.out.println("Antes de cerrar accion. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el bloque y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_parametros(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  nivel--;

  	  System.out.println("Después de cerrar acción");
  	  tabla_simbolos.imprimirTabla();
  	  
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de acción");
  }
}
/*
 * cabecera_accion	::=	<tACCION> identificador parametros_formales
 */
void cabecera_accion() :
{
  Token t;
  Simbolo s = new Simbolo();
  boolean ok = false;
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
  	<tACCION>
  	
  	t = identificador()
  	{
  	  // Procesar símbolo del identificador
  	  try {
  	    System.out.println("Se va a introducir una accion " + t.image);
  	    s = tabla_simbolos.introducir_accion(t.image, nivel, dir);
  	    ok = true;
  	  }
  	  catch (SimboloYaDeclaradoException e) {
  	    ErrorSemantico.deteccion(e, t);
  	  }
  	  nivel++;
  	}
  	
  	parametros = parametros_formales(t.image)
  	{
  	  if (ok) {
  	    s.setListaParametros(parametros);
  	  } 
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta la cabecera de la acción");
  }
}

/*
 * parametros_formales	::=	( parentesis_izq ( lista_parametros )? parentesis_der )?
 */
ArrayList<Simbolo> parametros_formales(String nombreAccion) :
{
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
	( parentesis_izq() ( parametros = lista_parametros() )? parentesis_der() )?
	{
	  return parametros;
	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * lista_parametros	::=	parametros ( fin_sentencia parametros )*
 */
ArrayList<Simbolo> lista_parametros() :
{
  ArrayList<Simbolo> parametros;
  ArrayList<Simbolo> parametrosAux;
}
{
  try {
  	parametros = parametros()
  	(
  	  fin_sentencia()
  	  parametrosAux = parametros()
  	  {
  	    parametros.addAll(parametrosAux);
  	  }
  	)*
  	{
  	  return parametros;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban uno o varios parámetros");
  }
}
/*
 * parametros	::=	clase_parametros tipo_variables identificadores
 */
ArrayList<Simbolo> parametros() :
{
  Clase_parametro clase;
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores = new ArrayList<Token>();

  Simbolo s;
  ArrayList<Simbolo> parametros = new ArrayList<Simbolo>();
}
{
  try {
  	clase = clase_parametros()
  	tipo = tipo_variables()
  	listaIdentificadores = identificadores()
  	{
  	  for (Token id : listaIdentificadores) {
  	    try {
  	      System.out.println("Se va a introducir un parametro: " + id.image + " " + tipo + " " + clase);
  	      s = tabla_simbolos.introducir_parametro(id.image, tipo, clase, nivel, dir);
  	      parametros.add(s);
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      // Si el símbolo está ya declarado, se introduce como un parámetro anónimo
  	      // en la lista de parametros para poder hacer la comprobación de signatura
  	      // al llamar a la función, pero no se mete en la tabla de simbolos. 
  	      ErrorSemantico.deteccion(e, id);
  	      s = new Simbolo();
  	      s.introducir_parametro("__anonymus", tipo, clase, nivel, dir);
  	      parametros.add(s);
  	    }
  	  }
  	  return parametros;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un parámetro");
  }
}
/*
 * clase_parametros	::=	( <tVAL> | <tREF> )
 */
Clase_parametro clase_parametros() :
{}
{
  try {
  	<tVAL> { return Clase_parametro.VAL; }
    | <tREF> { return Clase_parametro.REF; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de parametro");
  }
}


/*
 * bloque_sentencias	::=	principio lista_sentencias fin
 */
void bloque_sentencias() :
{}
{
  try {
    principio() lista_sentencias() fin()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un bloque se sentencias");
  }
}
/*
 * lista_sentencias	::=	sentencia ( sentencia )*
 */
void lista_sentencias() :
{}
{
  try {
    sentencia() ( sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban una o más sentencias");
  }
}
/*
 * sentencia	::=	( leer | escribir | identificacion | seleccion | mientras_que )
 */
void sentencia() :
{}
{
  try {
    leer()
  | escribir()
  | identificacion()
  | seleccion()
  | mientras_que()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una sentencia");
  }
}

/*
 * leer	::=	<tLEER> parentesis_izq lista_asignables parentesis_der fin_sentencia
 */
void leer() :
{
  Token t;
}
{
  try {
  	t = <tLEER> parentesis_izq() lista_asignables(t) parentesis_der() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia leer");
  }
}
/*
 * lista_asignables	::=	identificadores
 */
void lista_asignables(Token t) :
{
  ArrayList<RegistroExpr> listaExpr = null;
}
{
  try {
  	listaExpr = lista_expresiones()
  	{
  	  System.out.println(listaExpr.get(0));
  	  for (int i = 0; i < listaExpr.size(); i++) {
  	    if (!listaExpr.get(i).esDesc()) {
  	      if (listaExpr.get(i).esParVal()) {
            ErrorSemantico.deteccion(new InvocacionAccionException(), 
              "La expresión " + (i + 1) + " es un parámetro por valor, no es asignable", t);
          }
  	      if (!listaExpr.get(i).esAsignable()) {
  	        ErrorSemantico.deteccion(new InvocacionAccionException(), 
              "La expresión " + (i + 1) + " no es asignable", t);
  	      }
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de asignables");
  }
}
/*
 * escribir	::=	<tESCRIBIR> parentesis_izq lista_escribibles parentesis_der fin_sentencia
 */
void escribir() :
{
  ArrayList<RegistroExpr> listaExpr;
}
{
  try {
  	<tESCRIBIR> parentesis_izq() listaExpr = lista_escribibles() parentesis_der()  fin_sentencia()
  	{
  	   // Se pueden escribir variables simples.
  	   // Como salida se muestra el valor entero
       // o las cadenas "Verdadero" y "Falso"
       
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia escribir");
  }
}
/*
 * lista_escribibles	::=	escribible (sep_variable escribible)*
 */
ArrayList<RegistroExpr> lista_escribibles() :
{
  RegistroExpr reg;
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  
}
{
  try {
    // Expresiones y cadenas de caracteres
    reg = escribible()
    {
      listaExpr.add(reg);
    }
    (      sep_variable()
      reg = escribible()
      {
        listaExpr.add(reg);
      }
    )*
    {
      return listaExpr;
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de escribibles");
  }
}

RegistroExpr escribible() :
{
  RegistroExpr reg;
  Token t;
}
{
  try {
    reg = expresion()
    {
      return reg;
    }
  | t = < tCONSTCAD>
    {
      reg = new RegistroExpr();
      reg.setTipoCad();
      reg.setValorCad(t.image);
      return reg;
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un escribible");
  }
}

/*
 * asignacion	::=	<tOPAS> expresion fin_sentencia
 */
void asignacion(Tipo_variable tpID) :
{
  RegistroExpr reg;
  Token t;
}
{
  try {
    t = <tOPAS> reg = expresion() fin_sentencia()
    {
      if (tpID != Tipo_variable.DESCONOCIDO && !reg.esDesc() && tpID != reg.getTipo()) {
        ErrorSemantico.deteccion("Tipos incompatibles en la asignación", t);
      }
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación");
  }
}

/*
 * identificacion	::=	identificador ( ( argumentos )? fin_sentencia | asignacion )
 */
void identificacion() :
{
  Token t;
  Simbolo s = new Simbolo();
  Tipo_variable tpID = Tipo_variable.DESCONOCIDO;

  boolean ok = false;
  boolean hayArgumentos = false;
}
{
  try {
  	t = identificador()
  	{
	  try { 
  	    s = tabla_simbolos.buscar_simbolo(t.image);
  	    ok = true;
  	  }
  	  catch (SimboloNoEncontradoException e) {
  	    ErrorSemantico.deteccion(e, t);
  	    tpID = Tipo_variable.DESCONOCIDO;
  	  }
  	}
  	(
  	  // Llamada a acción. Comprobación de los argumentos
  	  {
  	    if (ok && !s.ES_ACCION()) {
  	      ErrorSemantico.deteccion(new InvocacionAccionException(), "El símbolo no es una acción", t);
  	    }
  	  }

  	  ( hayArgumentos = argumentos(s, ok))?
  	  
      {
        // TODO borrar
  	  // System.err.println("Accion " + s.getNombre() + " tiene argumentos " + hayArgumentos + " tipo " + tpID);
        
	     if (ok && s.ES_ACCION() && !hayArgumentos && !s.getListaParametros().isEmpty()) {
	       ErrorSemantico.deteccion(new InvocacionAccionException(),
  	         "La acción requiere " + s.getListaParametros().size() + " parámetros", t);
	     }
  	  }
  	  
  	  fin_sentencia()

  	  // Asignación
  	  |

		{
	      if (s.ES_ACCION()) {
  	        ErrorSemantico.deteccion("No se puede realizar una asignación a una acción", t);
  	        tpID = Tipo_variable.DESCONOCIDO;
  	      }
  	      else if (s.ES_PROGRAMA()) {
  	        ErrorSemantico.deteccion("No se puede realizar una asignación a un programa", t);
  	        tpID = Tipo_variable.DESCONOCIDO;
  	      }
  	      else if (s.ES_VARIABLE() || s.ES_PARAMETRO()) {
  	        if (s.ES_PARAMETRO() && s.ES_VALOR()) {
  	          ErrorSemantico.deteccion("No se puede realizar una asignación a un parámetro por valor", t);
  	        }
  	   	    tpID = s.getVariable();
  	   	  }
  	   	  else {
  	   	    tpID = Tipo_variable.DESCONOCIDO;
  	   	  }
  	    }
  	    asignacion(tpID) )
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación o una acción");
  }
}

/*
 * mientras_que	::=	<tMQ> expresion lista_sentencias <tFMQ>
 */
void mientras_que() :
{
  Token t;
  RegistroExpr reg;
}
{
  t = <tMQ>
  reg = expresion()
  {
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en el 'mientras_que' debe ser un booleano", t);
    }
    else if (reg.esBool() && reg.getValorBool() != null) {
      if (reg.getValorBool()) {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'true', se produce un bucle infinito", t);
      }
      else {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'false', el interior del bloque es código muerto", t);
      }
    }
  }
  lista_sentencias()
  try {
  	<tFMQ>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura MQ: 'FMQ'");
  }

}

/*
 * seleccion	::=	<tSI> expresion <tENT> lista_sentencias ( <tSI_NO> lista_sentencias )* <tFSI>
 */
void seleccion() :
{
  Token t;
  RegistroExpr reg;
}
{
  t = <tSI>
  reg = expresion()
  {
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en la selección debe ser un booleano", t);
    }
    else if (reg.esBool() && reg.getValorBool() != null && !reg.getValorBool()) {
      Aviso.deteccion("La expresión del 'si' es siempre 'false', el interior del bloque es código muerto", t);
    }
  }
  try {
  	<tENT>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el token 'ENT'");
  }
  lista_sentencias()
  ( <tSI_NO> lista_sentencias() )*
  try {
  	<tFSI>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura SI: 'FSI'");
  }
}

/*
 * argumentos	::=	parentesis_izq ( lista_expresiones )? parentesis_der
 */
boolean argumentos(Simbolo s, boolean ok) :
{
  ArrayList<RegistroExpr> listaExpr = null;
  ArrayList<Simbolo> listaParams = s.getListaParametros();
  Token t = token;
}
{
  try {
  	parentesis_izq() ( listaExpr = lista_expresiones() )? parentesis_der()
  	{
  	  if (!ok || listaExpr == null || listaExpr.size() <  1) {
  	    return false;
  	  }
  	    
  	  if (listaExpr.size() != listaParams.size()) {
  	    ErrorSemantico.deteccion(new InvocacionAccionException(),
  	      "El número de argumentos es incorrecto, se esperaban " + listaParams.size(), t);
  	  }
  	  // Comparar uno a uno, respentando el orden, los argumentos con los parámetros de la acción
  	  else {
        for (int i = 0; i < listaExpr.size(); i++) {
          if (!listaExpr.get(i).esDesc()) {
            if (listaExpr.get(i).getTipo() != listaParams.get(i).getVariable()) {
              ErrorSemantico.deteccion(new InvocacionAccionException(), 
              "El tipo del argumento " + (i + 1) + " no coincide con el del parámetro, se esperaba " + listaParams.get(i).getVariableString(), t);
            }
            else if (listaParams.get(i).ES_REFERENCIA()) {
              // Los argumentos que se pasan por referencia sólo pueden ser variables asignables,
              // no se puede pasar por referencia un parámetro por valor ni una expresión.
              if (listaExpr.get(i).esParVal()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(), 
                "El argumento " + (i + 1) + " es un parámetro por valor, no es asignable y no se puede pasar por referencia", t);
              }
              else if (!listaExpr.get(i).esAsignable()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(), 
                "La expresión del argumento " + (i + 1) + " no es asignable, así que no se puede pasar por referencia", t);
              }
            }
          }
        }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de argumentos");
  }
  {
    return true;
  }
}

/*
 * lista_expresiones	::=	expresion ( sep_variable expresion )*
 */
ArrayList<RegistroExpr> lista_expresiones() :
{
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  RegistroExpr reg;
}
{
  try {
    // Construir una lista con el tipo y clase de los argumentos
    reg = expresion()
    {
      listaExpr.add(reg);
    }
    (
      sep_variable()
      reg = expresion()
      {
        listaExpr.add(reg);
      }
    )*
    {
      return listaExpr;
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de expresiones");
  }
}



/*
 * expresion	::=	expresion_simple ( operador_relacional expresion_simple )?
 */
RegistroExpr expresion() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
  	reg1 = expresion_simple()
  	(
  	  op = operador_relacional()
  	  reg2 = expresion_simple()
  	  {
  	   	reg1 = RegistroExpr.operar(op, reg1, reg2);
  	  }
  	)?
  	{
  	  return reg1;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión");
  }
}
/*
 * operador_relacional	::=	( <tIGUAL> | <tMENOR> | <tMAYOR> | <tMAI> | <tMEI> | <tNI> )
 */
RegistroOp operador_relacional() :
{
  Token t;
  RegistroOp op;
}
{
  try {
  	t = <tIGUAL> { return new RegistroOp(t, RegistroOp.Operador.IGUAL); }
  | t = <tMENOR> { return new RegistroOp(t, RegistroOp.Operador.MENOR); }
  | t = <tMAYOR> { return new RegistroOp(t, RegistroOp.Operador.MAYOR); }
  | t = <tMAI>   { return new RegistroOp(t, RegistroOp.Operador.MAI); }
  | t = <tMEI>   { return new RegistroOp(t, RegistroOp.Operador.MEI); }
  | t = <tNI>    { return new RegistroOp(t, RegistroOp.Operador.NI); }
 }
 catch (ParseException e) {
   ErrorSintactico.deteccion(e, "Se esperaba un operador relacional: '=', ' >', '<', '<=', '>=', o '!='");
 }
}
/*
 * expresion_simple	::=	termino ( operador_aditivo termino )*
 */
RegistroExpr expresion_simple() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
    reg1 = termino()
    (
      op = operador_aditivo()
      reg2 = termino()
      {
        reg1 = RegistroExpr.operar(op, reg1, reg2);
      }
    )*
    {
      return reg1;
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión simple");
  }
}
/*
 * operador_aditivo	::=	( <tMAS> | <tMENOS> | <tOR> )
 */
RegistroOp operador_aditivo() :
{
  Token t;
  RegistroOp op;
}
{
  try {
    t = <tMAS>   { return new RegistroOp(t, RegistroOp.Operador.MAS); }
  | t = <tMENOS> { return new RegistroOp(t, RegistroOp.Operador.MENOS); }
  | t = <tOR>    { return new RegistroOp(t, RegistroOp.Operador.OR); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador aditivo: '+', '-', o 'OR'");
  }
}
/*
 * termino	::=	factor ( operador_multiplicativo factor )*
 */
RegistroExpr termino() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
    reg1 = factor()
    (
      op = operador_multiplicativo()
      reg2 = factor()
      {
        reg1 = RegistroExpr.operar(op, reg1, reg2);
      }
    )*
    {
      return reg1;
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un término");
  }
}
/*
 * operador_multiplicativo	::=	( <tPRODUCTO> | <tDIVISION> | <tMOD> | <tAND> )
 */
RegistroOp operador_multiplicativo() :
{
  Token t;
  RegistroOp op;
}
{
  try {
    t = <tPRODUCTO> { return new RegistroOp(t, RegistroOp.Operador.PRODUCTO); }
  | t = <tDIVISION> { return new RegistroOp(t, RegistroOp.Operador.DIVISION); }
  | t = <tMOD>      { return new RegistroOp(t, RegistroOp.Operador.MOD); }
  | t = <tDIV>      { return new RegistroOp(t, RegistroOp.Operador.DIV); }
  | t = <tAND>      { return new RegistroOp(t, RegistroOp.Operador.AND); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador multiplicativo: '*', '/', 'MOD', 'AND'");
  }
}
/*
 * factor	::=	( <tMENOS> factor
 *                  | <tMAS> factor
 *                  |  <tNOT> factor
 *					| parentesis_izq expresion parentesis_der
 *					| <tENTACAR> parentesis_izq expresion parentesis_der
 *					| <tCARAENT> parentesis_izq expresion parentesis_der
 *					| identificador | <tCONSTENTERA> | <tCONSTCHAR>
 *					| <tCONSTCAD> | <tTRUE> | <tFALSE> )
 */
RegistroExpr factor() :
{
  Token t = null;
  RegistroExpr reg = new RegistroExpr();
  Simbolo s;
}
{
  try {
    t = <tMENOS> reg = factor()
    {
      if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      else if (reg.esEnt() && reg.getValorEnt() != null) { 
        reg.setValorEnt(-reg.getValorEnt());
      }
      reg.setAsignable(false);
    }
 |  t = <tMAS> reg = factor()
    {
      if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      reg.setAsignable(false);
    }
  | t = <tNOT> reg = factor()
    {
      if (!reg.esBool() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba booleano", t);
        reg.setTipoBool();
      }
      else if (reg.esBool() && reg.getValorBool() != null) {
        reg.setValorBool(!reg.getValorBool());
      }
	  reg.setAsignable(false);
    }
  | parentesis_izq() reg = expresion() parentesis_der()
    {
     // No se realiza ninguna comprobación adicional
    }
  | t = <tENTACAR> parentesis_izq() reg = expresion() parentesis_der()
 	{
 	  if (!reg.esEnt() && !reg.esDesc()) {
 	    ErrorSemantico.deteccion("La expresión no se puede convertir en un carácter válido", t);
 	  }
 	  else if (reg.esEnt() && reg.getValorEnt() != null) {
 	    Integer carNum = reg.getValorEnt();
 	    if (carNum < 0 || carNum > 256) {
 	      ErrorSemantico.deteccion("La expresión no produce un entero ASCII válido", t);
 	    }
 	    else {
 	      reg.setValorChar((char)carNum.intValue());
 	    }
 	  }
 	  reg.setTipoChar();
 	  reg.setAsignable(false);
	}
  | t = <tCARAENT> parentesis_izq() reg = expresion() parentesis_der()
    {
      if (!reg.esChar() && !reg.esDesc()) {
        ErrorSemantico.deteccion("La expresión no se puede convertir en un entero válido", t);
      }
      else if (reg.esChar() && reg.getValorChar() != null) {
        Character car = reg.getValorChar();
        if (Character.isWhitespace(car)) {
          reg.setValorEnt(0);
        }
        else {
          // El caracter es ASCII, si no se habría producido un error léxico
       	  reg.setValorEnt((int) t.image.charAt(0));
       }
      }
      reg.setTipoEnt();
      reg.setAsignable(false);
    }
  | t = identificador()
    {
      try {
        reg = new RegistroExpr();
      	s = tabla_simbolos.buscar_simbolo(t.image);
      	if (s.ES_VARIABLE()) {
      	  reg.setTipo(s.getVariable());
      	  reg.setAsignable(true);
      	}
      	else if (s.ES_PARAMETRO()) {
      	  reg.setTipo(s.getVariable());
      	  if (s.ES_VALOR()) {
      	    reg.setParVal();
      	  }
      	  else if (s.ES_REFERENCIA()) {
      	    reg.setParRef();
      	    reg.setAsignable(true);
      	  }
      	}
      	else if (s.ES_ACCION()) {
      	  ErrorSemantico.deteccion("No se puede utilizar una acción dentro de una expresión", t);
      	  reg.setTipoDesc();
      	}
      	else if (s.ES_PROGRAMA()) {
      	  ErrorSemantico.deteccion("No se puede utilizar un programa dentro de una expresión", t);
      	  reg.setTipoDesc();
      	}
      	else {
      	  reg.setTipoDesc();
      	}
      }
      catch (SimboloNoEncontradoException e) {
        ErrorSemantico.deteccion(e, t);
        reg.setTipoDesc();
      }
    }
  | t = <tCONSTENTERA>
    {
      reg = new RegistroExpr();
      reg.setTipoEnt();
      reg.setValorEnt(Integer.parseInt(t.image));
    }
  | t = <tCONSTCHAR>
    {
      reg = new RegistroExpr();
      reg.setTipoChar();
      reg.setValorChar(t.image.charAt(0));
    }
  | <tTRUE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(true);
    }
  | <tFALSE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(false);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un factor");
  }
  {
    return reg;
  }
}

/*********************************************************************************
 * Especificación JavaCC para el lenguaje MiniLeng (Procesadores de Lenguajes)
 *
 * Fichero:    minilengcompiler.jj
 * Autor:      Fernando Peña (NIA: 756012)
 * Fecha:      29/03/2020
 * Versión:    v2.2
 * Asignatura: Procesadores de Lenguajes, curso 2019-2020
 **********************************************************************************/
options {
  static = true;
  ignore_case = true;
  // debug_parser = true;
}

PARSER_BEGIN(minilengcompiler)

package analizador;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.ArrayList;

import analizador.TokenMgrError;
import analizador.minilengcompilerTokenManager;
import analizador.SimpleCharStream;

import lib.lexico.TablaOcurrencias;
import lib.lexico.ErrorLexico;
import lib.sintactico.ErrorSintactico;
import lib.sintactico.PanicMode;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.*;
import lib.semantico.TablaSimbolos;
import lib.semantico.SimboloYaDeclaradoException;
import lib.semantico.SimboloNoEncontradoException;
import lib.semantico.InvocacionAccionException;
import lib.semantico.ErrorSemantico;
import lib.semantico.RegistroExpr;
import lib.semantico.RegistroOp;
import lib.semantico.UnderflowException;
import lib.semantico.OverflowException;
import lib.aviso.Aviso;


public class minilengcompiler {

  	private static final String version = "2.2";
  	private static final String fecha_version = "abril de 2020";
  	private static final String fecha_compilado = "10-04-2020";


	protected static Boolean verbose_mode = false;
	protected static Boolean panic_mode = false;
	protected static Boolean show_tokens = false;

	private static Boolean compilado_sin_errores = true;
	private static Boolean entrado_en_panic = false;

	private static TablaSimbolos tabla_simbolos;
	private static int nivel;
	private static int dir;


	private static void help() {
		System.out.println("Uso: minilengcompiler [opciones] fichero\n");
      	System.out.println("Opciones:");
      	System.out.println("  -v, --verbose  Mostrar un resumen de los símbolos utilizados en el programa");
      	System.out.println("  -p, --panic	 Compila con panic mode");
      	System.out.println("  -t, --tokens   Muestra los tokens que se van reconociendo");
      	System.out.println("  -h, --help	 Imprimir ayuda (esta pantalla) y salir");
      	System.out.println("  --version      Imprimir información de la versión y salir");

      	System.exit(0);
    }

    private static void version() {
		System.out.println("  Compilador de MiniLeng Versión " + version + "    Compilado el " + fecha_compilado);
		System.out.println("");
		System.out.println("    Prácticas de la asignatura: Procesadores de Lenguajes");
		System.out.println("      Curso 2019-2020");
		System.out.println("      Universidad de Zaragoza");
		System.out.println("");
		System.out.println("  Programado con JavaCC en Eclipse 2019-12");
		System.out.println("  JavaCC Eclipse Plug-in 1.5.33");

      	System.exit(0);
    }

    private static void opcionInvalida(String opcion) {
        System.err.println("MiniLeng: Opción inválida: '" + opcion + "'\n");
        help();
    }

    private static String procesarArgumentos(String args[]) {
      	String fichero_entrada = null;
		ArrayList<String> opciones = new ArrayList<String>();
		
      	// Obtener opciones
		for (String arg : args) {
		    if (arg.charAt(0) == '-') {
		      // opciones
		      if (arg.length() == 1) {
		          opcionInvalida(arg);
		      }
		      else if (arg.charAt(1) == '-') {
		          opciones.add(arg);
		      }
		      else {
		      	  for (String opt : arg.substring(1).split("")) {
		      	      opciones.add("-" + opt);
		      	  }
		      }
		    }
		    else {
		      // fichero de entrada
		      fichero_entrada = arg;
		      break;
		    }
		}

		// Activar opciones
		for (String opt : opciones) {
		    switch(opt) {
				case "-h":
				case "--help":
			    	help();
			    	break;
			    case "--version":
			        version();
			    	break;
			  	case "-v":
				case "--verbose":				
					verbose_mode = true;
					break;
				case "-p":
				case "--panic":
					panic_mode = true;
					break;
				case "-t":
				case "--tokens":
		        	show_tokens = true;
		        	break;
				default:
				    opcionInvalida(opt);
		    }
		}
		return fichero_entrada;
	}	


	public static void main(String args []) throws ParseException {
		System.out.println("Compilador de MiniLeng -- v" + version + " (" + fecha_version + ")");
    	System.out.println("Autor: Fernando Peña Bes (NIA: 756012)\n");

		// Entrada al programa
    	InputStream stream = System.in;
    	String fichero_entrada = procesarArgumentos(args);

		if (fichero_entrada != null) {
			// Si el fichero no terminal en .ml, error
			if (!fichero_entrada.endsWith(".ml")) {
        		System.err.println("MiniLeng: El fichero a compilar tiene que tener extensión .ml");
        		System.err.println("          Fichero introducido: '" + fichero_entrada + "'");
        		System.exit(0);
			}

			// Ejecutar el compilador con los fichero introducidos
			System.out.println("MiniLeng: Leyendo el fichero '" + fichero_entrada + "'...");
      		try {
        		stream = new FileInputStream(fichero_entrada);
      		}
      		catch (FileNotFoundException e) {
        		System.err.println("MiniLeng: No se ha encontrado el fichero '" + fichero_entrada + "'");
        		System.exit(0);
      		}
		}
		else {
  			help();
		}


		// Ejecución del compilador
        try {
    		minilengcompiler parser = new minilengcompiler(stream);
    		tabla_simbolos = new TablaSimbolos();
    		minilengcompiler.programa();
        }
        catch (Exception e) {
      		// TODO: ELIMINAR ESTO
      		System.err.println(e.getMessage());
      		
            System.err.println("Error en el compilador");
            System.err.println("Cabeza de lectura: (línea " + token.beginLine + ", columna " + token.beginColumn + ") " + token);
           	throw e;
        }
        catch (Error e) {
		  	// Detectado error léxico

		  	// TODO: ELIMINAR ESTO
		  	System.err.println(e.getMessage());
		  	
			SimpleCharStream entrada = minilengcompilerTokenManager.input_stream;
			String error;

			try {
				error = Character.toString(entrada.readChar());
			}
			catch (java.io.IOException fin_fichero) {
		  		error = "<EOF>";
			}

			ErrorLexico.deteccion(entrada.getEndLine(), entrada.getEndColumn(), error, TokenMgrError.addEscapes(error));
		}

		// Imprimir resultados de la compilación
		resultadosCompilacion(fichero_entrada);
    }

	static void resultadosCompilacion(String fichero_entrada) {
	  	System.out.println();

		// Cambiar extensión .ml por .code
	  	String fichero_salida = fichero_entrada.substring(0, fichero_entrada.length() - 2) + "code";
	  	
	  	// Mostrar contadores de errores
		if (ErrorLexico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores léxicos: " + ErrorLexico.getContadorErrores());
		}

		if (ErrorSintactico.getContadorErrores() > 0) {
		  	compilado_sin_errores = false;
		  	System.out.println("Errores sintácticos: " + ErrorSintactico.getContadorErrores());
		}

		if (ErrorSemantico.getContadorErrores() > 0) {
		  compilado_sin_errores = false;
		  System.out.println("Errores semánticos: " + ErrorSemantico.getContadorErrores());
		}

		if (Aviso.getContadorAvisos() > 0) {
			System.out.println("Avisos: " + Aviso.getContadorAvisos());
		}

	    if (PanicMode.getContadorErrores() > 0) {
		  	entrado_en_panic = true;
		  	System.out.println("Número de activaciones del panic mode: " + PanicMode.getContadorErrores());
		}

		// Resultados compilacion
		if (!compilado_sin_errores) {
		  	System.out.println("\nNo se ha podido compilar el programa.");
		}
		else if (entrado_en_panic) {
		  	System.out.println("\nSe ha activado el panic mode durante la compilación. Es necesario corregir los errores y volver a compilar.");
		}
		else {
		  	System.out.println("\nCompilación finalizada. Se ha generado el fichero '" + fichero_salida + "'");
		}
	}
}

PARSER_END(minilengcompiler)



/**** Análisis léxico ****/

TOKEN_MGR_DECLS : {
  // Crear e inicializar tabla de ocurrencias
  static TablaOcurrencias tabla_ocurrencias = new TablaOcurrencias(minilengcompiler.show_tokens);
}
SKIP : {  " "| "\r"| "\t"| "\n"
| < "%"~["%"] > : COMENTARIO
| "%%"          : MULTICOMENTARIO}

// Ignorar comentarios en la entrada
< COMENTARIO > SKIP : {
  "\n" : DEFAULT
}

<COMENTARIO> MORE : {
   < ~[] >
}

<MULTICOMENTARIO> SKIP : {
  "%%" : DEFAULT
}

<MULTICOMENTARIO> MORE : {
   < ~[] >
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPROGRAMA);
  }
| < tVAR : "var" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAR);
  }
| < tPRINCIPIO : "principio" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tPRINCIPIO);
  }
| < tFIN : "fin" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFIN);
  }
| < tSI : "si" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI);
  }
| < tENT : "ent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENT);

  }
| < tSI_NO : "si_no" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tSI_NO);
  }
| < tFSI : "fsi" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFSI);
  }
| < tMQ : "mq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tMQ);
  }
| < tFMQ : "fmq" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tFMQ);
  }
| < tESCRIBIR : "escribir" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tESCRIBIR);
  }
| < tLEER : "leer" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tLEER);
  }

  // Funciones predefinidas
| < tENTACAR : "entacar" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tENTACAR);
  }
| < tCARAENT : "caraent" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tCARAENT);
  }

  // Funciones
| < tACCION : "accion" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tACCION);
  }
| < tVAL : "val" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tVAL);
  }
|  < tREF : "ref" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Reservadas.tREF);
  }
}


TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tENTERO);
  }
| < tBOOLEANO : "booleano" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tBOOLEANO);
  }
| < tCARACTER : "caracter" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Tipos.tCARACTER);
  }
}


TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_IZQ);
  }
| < tLLAVE_DER : "}" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tLLAVE_DER);
  }
| < tPARENTESIS_IZQ : "(" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_IZQ);
  }
| < tPARENTESIS_DER : ")" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Agrupaciones.tPARENTESIS_DER);
  }
}


TOKEN : /* VECTORES */
{
  < tCORCHETE_IZQ : "[" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_IZQ);
  }
  
| < tCORCHETE_DER : "]" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Vectores.tCORCHETE_DER);
  }
}


TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tOPAS);
  }

| < tFIN_SENTENCIA : ";" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tFIN_SENTENCIA);
  }
| < tSEP_VARIABLE : "," >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Operadores.tSEP_VARIABLE);
  }

  // Aritméticos
| < tMAS : "+" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMAS);
  }
| < tMENOS : "-" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMENOS);
  }
| < tPRODUCTO : "*" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tPRODUCTO);
  }
| < tDIVISION : "/" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIVISION);
  }
| < tMOD : "mod" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tMOD);
  }
| < tDIV : "div" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpAritmeticos.tDIV);
  }

  // Lógicos
| < tAND : "and" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tAND);
  }
| < tOR : "or" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tOR);
  }
| < tNOT : "not" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNOT);
  }
| < tMAYOR : ">" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAYOR);
  }
| < tMENOR : "<" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMENOR);
  }
| < tIGUAL : "=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tIGUAL);
  }
| < tMAI : ">=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMAI);
  }
| < tMEI : "<=" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tMEI);
  }
| < tNI : "<>" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.OpLogicos.tNI);
  }
}


TOKEN : /* VALORES */
{
  < #DIGITO : [ "0"-"9" ] >
| < #LETRA : [ "a"-"z" ] >

  // Booleanos
| < tTRUE : "true" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tTRUE, "True");
  }
| < tFALSE : "false" >
  {
     tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tFALSE, "False");
  }

  // Identificadores
| < tIDENTIFICADOR : (< LETRA > | "_"(< LETRA > | < DIGITO >))(("_")?(< LETRA > | < DIGITO >))* >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tIDENTIFICADOR, matchedToken.image);
  }

  // Enteros
  // | < tCONSTENTERA : ("+" | "-")?(["0"-"9"])+ >
| < tCONSTENTERA : (["0"-"9"])+ >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTENTERA, matchedToken.image);
  }

   // Caracteres
| < tCONSTCHAR : "\""(~["\""])?"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCHAR, matchedToken.image);
  }

  // Cadena de caracteres
| < tCONSTCAD : "\""(~["\""])*"\"" >
  {
    tabla_ocurrencias.incrementar(TablaOcurrencias.Valores.tCONSTCAD, matchedToken.image);
  }
}



/**** Análisis sintáctico ****/

// Inicio programa

/*
 * programa	::=	<tPROGRAMA> identificador fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias <EOF>
 */
int programa() :
{
  int nivel = 0;
  tabla_simbolos.inicializar_tabla();

  Token t;
}
{
  try {
  	<tPROGRAMA> 
  	t = identificador()
  	{
  	  	System.out.println("Leído programa " + t.image);
  		tabla_simbolos.introducir_programa(t.image, 0);
  	}
  	
  	fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias() < EOF >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "La declaración del programa es incorrecta");
  }

  {
      System.out.println("Antes de cerrar programa. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el programa y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  tabla_simbolos.eliminar_programa();

  	  System.out.println("Después de cerrar programa");
  	  tabla_simbolos.imprimirTabla();
  }

  {
    if (verbose_mode) {
      token_source.tabla_ocurrencias.imprimirTabla();
    }

	// Fin del compilador
    return 0;
  }

}




// Declaraciones de separadores y limitadores de bloque

void fin_sentencia() :
{}
{
  try {
    < tFIN_SENTENCIA >
  }
  catch (ParseException e) {
    // Si el modo pánico está activado, descartar entrada hasta el siguiente ;
    if (panic_mode) {
      PanicMode.iniciar(e, "Se esperaba ';'", tFIN_SENTENCIA, ";");
    }
    else {
      ErrorSintactico.deteccion(e, "Se esperaba ';'");
    }
  }
}
void sep_variable() :
{}
{
  try {
    < tSEP_VARIABLE >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ','");
  }
}

void parentesis_izq() :
{}
{
  try {
    < tPARENTESIS_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta paréntesis de cierre: ')'");
  }
}
void parentesis_der() :
{}
{
  try {
    < tPARENTESIS_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '('");
  }
}

void corchete_izq() :
{}
{
  try {
    < tCORCHETE_IZQ >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba '['");
  }
}
void corchete_der() :
{}
{
  try {
    < tCORCHETE_DER >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba ']'");
  }
}

Integer longitud_const() :
{
  Token t;
  Integer len = null;
}
{
  try { 
    t = < tCONSTENTERA >
    { 
      len = Integer.parseInt(t.image);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una constante entera");
  }
  {
    return len;
  }
}

void principio() :
{}
{
  try {
    < tPRINCIPIO >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de principio de bloque: 'principio'");
  }
}
void fin() :
{}
{
  try {
    < tFIN >
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador fin de bloque: 'fin'");
  }
}

Token identificador() :
{
  Token t = null;
}
{
  try { 
  	t = < tIDENTIFICADOR >
  }
  catch(ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un identificador");
  }
  {
    return t;
  } 
}




// Declaracion de variables

/*
 * declaracion_variables ::= ( declaracion fin_sentencia )*
 */
void declaracion_variables() :
{}
{
  try {
    {
      System.out.println("Entrado en declaracion de variables");
    }
  	( declaracion() fin_sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion ::= tipo_variables identificadores
 */
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList<Token> listaIdentificadores;
}
{
  try {
  	tipo = tipo_variables()
  	identificadores(tipo)
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de variables");
  }
}
/*
 * tipo_variables	::=	( <tENTERO> | <tCARACTER> | <tBOOLEANO> )
 */
Tipo_variable tipo_variables() :
{
  Tipo_variable variable = null;
}
{
  try {
  	<tENTERO> { variable = Tipo_variable.ENTERO; }
  | <tCARACTER> { variable = Tipo_variable.CHAR; }
  | <tBOOLEANO> { variable = Tipo_variable.BOOLEANO; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de dato");
  }
  {
    return variable;
  }
}
/*
 * identificadores	::=	(identificador | vector) ( sep_variable (identificador | vector) )*
 */
void identificadores(Tipo_variable tipo) :
{
}
{
  try {
  	identificador_declaracion(tipo) (sep_variable() identificador_declaracion(tipo))*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba uno o varios identificadores o vectores");
  }
}

void identificador_declaracion(Tipo_variable tipo) :
{
  Token id = null;
  Integer len = null;
}
{
  try {
    id = identificador() ( corchete_izq() len = longitud_const() corchete_der() )?
    { 
      try {
        if (id != null && tipo != null) { 
          System.err.println("Identificador declaracion " + id.image + " " + len);
          if (len == null) {
            // variable
            System.out.println("Se va a introducir una variable: " + id.image);
            tabla_simbolos.introducir_variable(id.image, tipo, nivel, dir);
          }
          else {
            // vector
            System.out.println("Se va a introducir una variable vector: " + id.image + " " + len);
            tabla_simbolos.introducir_variable_vector(id.image, tipo, len, nivel, dir);
          }
          dir++;
  	    }
  	  }
  	  catch (SimboloYaDeclaradoException e) {
  	    ErrorSemantico.deteccion(e, id);
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la declaración de una variable o vector");
  }
}



// Declaración de acciones

/*
 * declaracion_acciones	::=	( declaracion_accion )*
 */
void declaracion_acciones() :
{}
{
  try {
  	( declaracion_accion() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "");
  }
}
/*
 * declaracion_accion	::=	cabecera_accion fin_sentencia declaracion_variables declaracion_acciones bloque_sentencias
 */
void declaracion_accion() :
{}
{
  try {
  	cabecera_accion() fin_sentencia()
  	declaracion_variables()
  	declaracion_acciones()
  	bloque_sentencias()

  	{

  	  System.out.println("Antes de cerrar accion. nivel " + nivel);
      tabla_simbolos.imprimirTabla();
      
  	  // Cerrar el bloque y limpiar la tabla de símbolos
  	  tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_parametros(nivel);
  	  tabla_simbolos.eliminar_acciones(nivel);
  	  nivel--;

  	  System.out.println("Después de cerrar acción");
  	  tabla_simbolos.imprimirTabla();
  	  
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una declaración de acción");
  }
}
/*
 * cabecera_accion	::=	<tACCION> identificador ( parametros_formales )?
 */
void cabecera_accion() :
{
  Token id;
  Simbolo s = null;
}
{
  try {
  	<tACCION>
  	
  	id = identificador()
  	{
  	  // Procesar símbolo del identificador
  	  if (id != null) { 
  	    try {
  	      System.out.println("Se va a introducir una accion " + id.image);
  	      s = tabla_simbolos.introducir_accion(id.image, nivel, dir);
  	    }
  	    catch (SimboloYaDeclaradoException e) {
  	      ErrorSemantico.deteccion(e, id);
  	    }
  	    nivel++;
  	  }
  	}
  	
  	( parametros_formales(s) )?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Falta la cabecera de la acción");
  }
}

/*
 * parametros_formales	::=	parentesis_izq ( parametros ( fin_sentencia parametros )* )? parentesis_der
 */
void parametros_formales(Simbolo s) :
{}
{
  try {
    parentesis_izq()
    ( parametros(s) ( fin_sentencia() parametros(s) )* )?
    parentesis_der()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban los parametros formales de la accion");
  }
}

/*
 * parametros	::=	clase_parametros tipo_variables identificadores
 */
void parametros(Simbolo s) :
{
  Clase_parametro clase;
  Tipo_variable tipo;
}
{
  try {
    clase = clase_parametros()
    tipo = tipo_variables()
    lista_parametros(clase, tipo, s)
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban parámetros");
  }
}
/*
 * lista_parametros	::=	parametros ( sep_variable parametros )*
 */
void lista_parametros(Clase_parametro clase, Tipo_variable tipo, Simbolo s) :
{}
{
  try { 
    identificador_parametro(clase, tipo, s)
    ( sep_variable() identificador_parametro(clase, tipo, s) )*
  }
  catch (ParseException e) {
	ErrorSintactico.deteccion(e, "Se esperaba una lista de parámetros");
  }
}
/*
 * clase_parametros	::=	( <tVAL> | <tREF> )
 */
Clase_parametro clase_parametros() :
{
  Clase_parametro clase = null;
}
{
  try {
  	  <tVAL> { clase = Clase_parametro.VAL; }
    | <tREF> { clase = Clase_parametro.REF; }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un tipo de parametro");
  }
  {
    return clase;
  }
}


void identificador_parametro(Clase_parametro clase, Tipo_variable tipo, Simbolo s) :
{
  Token id;
  Integer len = null;
  Simbolo par = null;
}
{
  try { 
    id = identificador() ( corchete_izq() len = longitud_const() corchete_der() )?
    {
      if (id != null && clase != null && tipo != null) { 
        try { 
          if (len == null) {
            // parametro
	        System.out.println("Se va a introducir un parametro: " + id.image + " " + tipo + " " + clase);
  	        par = tabla_simbolos.introducir_parametro(id.image, tipo, clase, nivel, dir);
          }
          else {
            // parametro vector
            System.out.println("Se va a introducir un parametro vector: " + id.image + " " + tipo + " " + clase);
	        par = tabla_simbolos.introducir_parametro_vector(id.image, tipo, clase, len, nivel, dir);
          }

          if (s != null) {
            // añadir el parametro a la acción
            s.addParametro(par);
          }
        }
        catch (SimboloYaDeclaradoException e) {
          // Si el símbolo está ya declarado, se introduce como un parámetro anónimo
  	      // en la lista de parametros para poder hacer la comprobación de signatura
  	      // al llamar a la función, pero no se mete en la tabla de simbolos. 
  	      ErrorSemantico.deteccion(e, id);
  	      s = new Simbolo();
  	      s.introducir_parametro("__anonymus", tipo, clase, nivel, dir);
        }
      }
    }
  }
  catch (ParseException e) {
	ErrorSintactico.deteccion(e, "Se esperaba un parámetro");
  }
}




// Sentencias

/*
 * bloque_sentencias	::=	principio lista_sentencias fin
 */
void bloque_sentencias() :
{}
{
  try {
    principio() lista_sentencias() fin()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un bloque se sentencias");
  }
}
/*
 * lista_sentencias	::=	sentencia ( sentencia )*
 */
void lista_sentencias() :
{}
{
  try {
    sentencia() ( sentencia() )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaban una o más sentencias");
  }
}
/*
 * sentencia	::=	( leer | escribir | identificacion | seleccion | mientras_que )
 */
void sentencia() :
{}
{
  try {
    leer()
  | escribir()
  | identificacion()
  | seleccion()
  | mientras_que()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una sentencia");
  }
}

/*
 * leer	::=	<tLEER> parentesis_izq lista_asignables parentesis_der fin_sentencia
 */
void leer() :
{
  Token t;
}
{
  try {
  	t = <tLEER> parentesis_izq() lista_asignables(t) parentesis_der() fin_sentencia()
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia leer");
  }
}
/*
 * lista_asignables	::=	identificadores
 */
void lista_asignables(Token t) :
{
  ArrayList<RegistroExpr> listaExpr;
}
{
  try {
  	listaExpr = lista_expresiones()
  	{
  	  System.out.println(listaExpr.get(0));
  	  for (int i = 0; i < listaExpr.size(); i++) {
  	    if (!listaExpr.get(i).esDesc()) {
  	      if (listaExpr.get(i).esVector()) {
            ErrorSemantico.deteccion(new InvocacionAccionException(), 
  	          "La expresión " + (i + 1) + " es un vector, no es asignable en una instrucción leer", t);
  	      }
  	      else if (listaExpr.get(i).esParVal()) {
            ErrorSemantico.deteccion(new InvocacionAccionException(), 
              "La expresión " + (i + 1) + " es un parámetro por valor, no es asignable", t);
          }
  	      else if (!listaExpr.get(i).esAsignable()) {
  	        ErrorSemantico.deteccion(new InvocacionAccionException(), 
              "La expresión " + (i + 1) + " no es asignable", t);
  	      }
  	    }
  	  }
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de asignables");
  }
}
/*
 * escribir	::=	<tESCRIBIR> parentesis_izq lista_escribibles parentesis_der fin_sentencia
 */
void escribir() :
{
  ArrayList<RegistroExpr> listaExpr;
}
{
  try {
  	<tESCRIBIR> parentesis_izq() listaExpr = lista_escribibles() parentesis_der()  fin_sentencia()
  	{
  	   // Se pueden escribir variables simples.
  	   // Como salida se muestra el valor entero
       // o las cadenas "Verdadero" y "Falso"

       // Pensar si se pueden escribir vectores
       
  	}
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba la sentencia escribir");
  }
}
/*
 * lista_escribibles	::=	escribible (sep_variable escribible)*
 */
ArrayList<RegistroExpr> lista_escribibles() :
{
  RegistroExpr reg;
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  
}
{
  try {
    // Expresiones y cadenas de caracteres
    reg = escribible()
    {
      if (reg != null) { 
        listaExpr.add(reg);
      }
    }
    (      sep_variable()
      reg = escribible()
      {
        if (reg != null) { 
          listaExpr.add(reg);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de escribibles");
  }
  {
    return listaExpr;
  }
}

RegistroExpr escribible() :
{
  RegistroExpr reg = null;
  Token t;
}
{
  try {
    reg = expresion()
  | t = < tCONSTCAD>
    {
      reg = new RegistroExpr();
      reg.setTipoCad();
      reg.setValorCad(t.image);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un escribible");
  }
  {
    return reg;
  }
}


/*
 * mientras_que	::=	<tMQ> expresion lista_sentencias <tFMQ>
 */
void mientras_que() :
{
  Token t;
  RegistroExpr reg;
}
{
  t = <tMQ>
  reg = expresion()
  {
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en el 'mientras_que' debe ser un booleano", t);
    }
    else if (reg.esBool() && reg.getValorBool() != null) {
      if (reg.getValorBool()) {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'true', se produce un bucle infinito", t);
      }
      else {
        Aviso.deteccion("La expresión del 'mientras_que' siempre es 'false', el interior del bloque es código muerto", t);
      }
    }
  }
  lista_sentencias()
  try {
  	<tFMQ>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura MQ: 'FMQ'");
  }

}

/*
 * seleccion	::=	<tSI> expresion <tENT> lista_sentencias ( <tSI_NO> lista_sentencias )* <tFSI>
 */
void seleccion() :
{
  Token t;
  RegistroExpr reg;
}
{
  t = <tSI>
  reg = expresion()
  {
    if (!reg.esDesc() && !reg.esBool()) {
      ErrorSemantico.deteccion("La condición en la selección debe ser un booleano", t);
    }
    else if (reg.esBool() && reg.getValorBool() != null && !reg.getValorBool()) {
      Aviso.deteccion("La expresión del 'si' es siempre 'false', el interior del bloque es código muerto", t);
    }
  }
  try {
  	<tENT>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el token 'ENT'");
  }
  lista_sentencias()
  ( <tSI_NO> lista_sentencias() )*
  try {
  	<tFSI>
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba el delimitador de fin de estructura SI: 'FSI'");
  }
}






/*
 * identificacion	::=	identificador ( ( argumentos )? fin_sentencia | asignacion )
 */
void identificacion() :
{
  Token t;
  RegistroExpr indice = null;
  
  Simbolo s = null;
  Tipo_variable tpID = Tipo_variable.DESCONOCIDO;

  boolean hayArgumentos = false;
}
{
  try {
  	t = identificador()
  	{
	  try { 
  	    s = tabla_simbolos.buscar_simbolo(t.image);
  	  }
  	  catch (SimboloNoEncontradoException e) {
  	    ErrorSemantico.deteccion(e, t);
  	  }
  	}

    (      ( corchete_izq() indice = expresion() corchete_der() )? asignacion(s, indice, t) fin_sentencia()
      
    | ( hayArgumentos = argumentos(s, t) )? fin_sentencia()
      {
        if (s != null) { 
          if (!s.ES_ACCION()) {
            ErrorSemantico.deteccion(new InvocacionAccionException(),
              "El simbolo no es una accion", t);
          }
          else if (!s.getListaParametros().isEmpty() && !hayArgumentos) {
            ErrorSemantico.deteccion(new InvocacionAccionException(),
  	          "La acción requiere " + s.getListaParametros().size() + " argumentos", t);
          }
        }
      }
    )
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación o una acción");
  }
}



/*
 * asignacion	::=	<tOPAS> expresion fin_sentencia
 */
void asignacion(Simbolo s, RegistroExpr indice, Token izq) :
{
  RegistroExpr reg;
  Token t;
}
{
  try {
    t = <tOPAS> reg = expresion()
    {
      if (s != null && !reg.esDesc()) {
        if (!s.ES_VECTOR() && indice != null) {
          ErrorSemantico.deteccion("El símbolo no es un vector", izq);
        }
        else if (s.ES_ACCION()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a una acción", izq);
  	    }
  	    else if (s.ES_PROGRAMA()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a un programa", izq);
  	    }
  	    else if (s.ES_PARAMETRO() && s.ES_VALOR()) {
  	      ErrorSemantico.deteccion("No se puede realizar una asignación a un parámetro por valor", izq);
  	   	}
  	   	else if (s.ES_VARIABLE() || (s.ES_PARAMETRO() && s.ES_REFERENCIA())) {
  	   	  if (s.getVariable() != reg.getTipo() || (s.ES_VECTOR() ^ (indice != null)) != reg.esVector()) {
  	   	    System.err.print(s.getVariable() + " " + reg.getTipo() + " " + s.ES_VECTOR() + " " + (indice == null) + " " + reg.esVector() + "\n");
            ErrorSemantico.deteccion("Tipos incompatibles en la asignación", t);
  	   	  }
  	   	  else if (s.ES_VECTOR() && reg.esVector() && s.getLongitud() != reg.getLongitud()) {
  	   	    ErrorSemantico.deteccion("No se puede realizar la asignación de vectores de diferente longitud", t);
  	   	  }
  	   	  else {
  	   	    // La asignación es correcta
  	   	    System.err.println("La asignación es correcta");
  	   	  }
  	   	}
  	  }
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una asignación");
  }
}




/*
 * argumentos	::=	parentesis_izq ( lista_expresiones )? parentesis_der
 */
boolean argumentos(Simbolo s, Token t) :
{
  ArrayList<RegistroExpr> listaExpr = null;
  ArrayList<Simbolo> listaParams;

  boolean hayArgumentos = false;
}
{
  try {
  	parentesis_izq() ( listaExpr = lista_expresiones() )? parentesis_der()
	{
	  if (s != null && listaExpr != null && s.ES_ACCION()) {
	    hayArgumentos = true;

	    listaParams = s.getListaParametros();
	      	    
  	  	if (listaExpr.size() != listaParams.size()) {
  	      ErrorSemantico.deteccion(new InvocacionAccionException(),
  	      "El número de argumentos es incorrecto, se esperaban " + listaParams.size(), t);
  	    }
  	    else {
          for (int i = 0; i < listaExpr.size(); i++) {
            RegistroExpr arg = listaExpr.get(i);
            Simbolo param = listaParams.get(i);
            
            if (!arg.esDesc()) {

              // Comprobar tipo
              if ((arg.getTipo() != param.getVariable() || arg.esVector() != param.ES_VECTOR())
                   || (arg.esVector() && param.ES_VECTOR() && arg.getLongitud() != param.getLongitud())) {
                     
                String tipoEsperado = param.getVariableString();
                if (param.ES_VECTOR()) {
                  tipoEsperado += "[" + param.getLongitud() + "]";
                }
                
                ErrorSemantico.deteccion(new InvocacionAccionException(), 
                  "El tipo del argumento " + (i + 1) + " no coincide con el del parámetro, se esperaba " + tipoEsperado, t);
              }

              // Comprobar que se pase como referencia un argumento asignable
              else if (param.ES_REFERENCIA() && arg.esParVal()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(), 
                  "El argumento " + (i + 1) + " es un parámetro por valor, no es asignable y no se puede pasar por referencia", t);
			  }  
              else if (param.ES_REFERENCIA() && !arg.esAsignable()) {
                ErrorSemantico.deteccion(new InvocacionAccionException(), 
                    "La expresión del argumento " + (i + 1) + " no es asignable, así que no se puede pasar por referencia", t);
              }
              else {
                // El argumento es válido
                System.err.println("El argumento es válido");
              }
            }
          }
        }
      }
    }
  }           
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de argumentos");
  }
  {
    return hayArgumentos;
  }
}








// Expresiones

/*
 * lista_expresiones	::=	expresion ( sep_variable expresion )*
 */
ArrayList<RegistroExpr> lista_expresiones() :
{
  ArrayList<RegistroExpr> listaExpr = new ArrayList<RegistroExpr>();
  RegistroExpr reg;
}
{
  try {
    // Construir una lista con el tipo y clase de los argumentos
    reg = expresion()
    {
      listaExpr.add(reg);
    }
    (
      sep_variable()
      reg = expresion()
      {
        listaExpr.add(reg);
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una lista de expresiones");
  }
  {
    return listaExpr;
  }
}


/*
 * expresion	::=	expresion_simple ( operador_relacional expresion_simple )?
 */
RegistroExpr expresion() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
  	reg1 = expresion_simple()
  	(
  	  op = operador_relacional()
  	  reg2 = expresion_simple()
  	  {
  	    if (op != null) { 
  	   	  reg1 = RegistroExpr.operar(op, reg1, reg2);
  	   	}
  	  }
  	)?
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión");
  }
  {
    return reg1;
  }
}
/*
 * operador_relacional	::=	( <tIGUAL> | <tMENOR> | <tMAYOR> | <tMAI> | <tMEI> | <tNI> )
 */
RegistroOp operador_relacional() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
  	t = <tIGUAL> { op = new RegistroOp(t, RegistroOp.Operador.IGUAL); }
  | t = <tMENOR> { op = new RegistroOp(t, RegistroOp.Operador.MENOR); }
  | t = <tMAYOR> { op = new RegistroOp(t, RegistroOp.Operador.MAYOR); }
  | t = <tMAI>   { op = new RegistroOp(t, RegistroOp.Operador.MAI); }
  | t = <tMEI>   { op = new RegistroOp(t, RegistroOp.Operador.MEI); }
  | t = <tNI>    { op = new RegistroOp(t, RegistroOp.Operador.NI); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador relacional: '=', ' >', '<', '<=', '>=', o '!='");
  }
  {
    return op;
  }
}
/*
 * expresion_simple	::=	termino ( operador_aditivo termino )*
 */
RegistroExpr expresion_simple() :
{
  RegistroExpr reg1 = new RegistroExpr();
  RegistroExpr reg2 = new RegistroExpr();
  RegistroOp op;
}
{
  try {
    reg1 = termino()
    (
      op = operador_aditivo()
      reg2 = termino()
      {
        if (op != null) { 
          reg1 = RegistroExpr.operar(op, reg1, reg2);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba una expresión simple");
  }
  {
    return reg1;
  }
}
/*
 * operador_aditivo	::=	( <tMAS> | <tMENOS> | <tOR> )
 */
RegistroOp operador_aditivo() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
    t = <tMAS>   { op = new RegistroOp(t, RegistroOp.Operador.MAS); }
  | t = <tMENOS> { op = new RegistroOp(t, RegistroOp.Operador.MENOS); }
  | t = <tOR>    { op = new RegistroOp(t, RegistroOp.Operador.OR); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador aditivo: '+', '-', o 'OR'");
  }
  {
    return op;
  }
}
/*
 * termino	::=	factor ( operador_multiplicativo factor )*
 */
RegistroExpr termino() :
{
  RegistroExpr reg1 = null;
  RegistroExpr reg2;
  RegistroOp op;
}
{
  try {
    reg1 = factor()
    (
      op = operador_multiplicativo()
      reg2 = factor()
      {
        if (op != null) { 
          reg1 = RegistroExpr.operar(op, reg1, reg2);
        }
      }
    )*
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un término");
  }
  {
    return reg1;
  }
}
/*
 * operador_multiplicativo	::=	( <tPRODUCTO> | <tDIVISION> | <tMOD> | <tAND> )
 */
RegistroOp operador_multiplicativo() :
{
  Token t;
  RegistroOp op = null;
}
{
  try {
    t = <tPRODUCTO> { op = new RegistroOp(t, RegistroOp.Operador.PRODUCTO); }
  | t = <tDIVISION> { op = new RegistroOp(t, RegistroOp.Operador.DIVISION); }
  | t = <tMOD>      { op = new RegistroOp(t, RegistroOp.Operador.MOD); }
  | t = <tDIV>      { op = new RegistroOp(t, RegistroOp.Operador.DIV); }
  | t = <tAND>      { op = new RegistroOp(t, RegistroOp.Operador.AND); }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un operador multiplicativo: '*', '/', 'MOD', 'AND'");
  }
  {
    return op;
  }
}
/*
 * factor	::=	( <tMENOS> factor
 *                  | <tMAS> factor
 *                  |  <tNOT> factor
 *					| parentesis_izq expresion parentesis_der
 *					| <tENTACAR> parentesis_izq expresion parentesis_der
 *					| <tCARAENT> parentesis_izq expresion parentesis_der
 *					| identificador | <tCONSTENTERA> | <tCONSTCHAR>
 *					| <tCONSTCAD> | <tTRUE> | <tFALSE> )
 */
RegistroExpr factor() :
{
  Token t = null;
  Simbolo s;
  RegistroExpr indice = null;
  
  RegistroExpr reg = new RegistroExpr();
  reg.setTipoDesc();
}
{
  try {
    t = <tMENOS> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
        reg.setTipoEnt();
      }
      else if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      else if (reg.esEnt() && reg.getValorEnt() != null) { 
        reg.setValorEnt(-reg.getValorEnt());
      }
      reg.setAsignable(false);
        
      // Generacion código
      reg.getInstr().addMenosUnario();
    }
 |  t = <tMAS> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
        reg.setTipoEnt();
      }
      else if (!reg.esEnt() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba entero", t);
        reg.setTipoEnt();
      }
      reg.setAsignable(false);
    }
  | t = <tNOT> reg = factor()
    {
      if (reg.esVector()) {
        ErrorSemantico.deteccion("No se pueden realizar operaciones con vectores", t);
        reg.setVector(false);
      }
      else if (!reg.esBool() && !reg.esDesc()) {
        ErrorSemantico.deteccion("Tipo incompatible. Se esperaba booleano", t);
        reg.setTipoBool();
      }
      else if (reg.esBool() && reg.getValorBool() != null) {
        reg.setValorBool(!reg.getValorBool());
      }
	  reg.setAsignable(false);
	          
	  // Generacion código
	  reg.getInstr().addNegacionUnaria();
    }
  | parentesis_izq() reg = expresion() parentesis_der()
    {
     // No se realiza ninguna comprobación adicional
    }
  | t = <tENTACAR> parentesis_izq() reg = expresion() parentesis_der()
 	{
 	  if (reg.esVector() || !reg.esEnt() && !reg.esDesc()) {
 	    ErrorSemantico.deteccion("La expresión no se puede convertir en un carácter válido", t);
 	    reg.setVector(false);
 	  }
 	  else if (reg.esEnt() && reg.getValorEnt() != null) {
 	    Integer carNum = reg.getValorEnt();
 	    if (carNum < 0 || carNum > 256) {
 	      ErrorSemantico.deteccion("La expresión no produce un entero ASCII válido", t);
 	    }
 	    else {
 	      reg.setValorChar((char)carNum.intValue());
 	    }
 	  }
 	  reg.setTipoChar();
 	  reg.setAsignable(false);
	}
  | t = <tCARAENT> parentesis_izq() reg = expresion() parentesis_der()
    {
      if (reg.esVector() || !reg.esChar() && !reg.esDesc()) {
        ErrorSemantico.deteccion("La expresión no se puede convertir en un entero válido", t);
        reg.setVector(false);
      }
      else if (reg.esChar() && reg.getValorChar() != null) {
        Character car = reg.getValorChar();
        if (Character.isWhitespace(car)) {
          reg.setValorEnt(0);
        }
        else {
          // El caracter es ASCII, si no se habría producido un error léxico
       	  reg.setValorEnt((int) t.image.charAt(0));
       }
      }
      reg.setTipoEnt();
      reg.setAsignable(false);
    }
  | t = identificador() ( corchete_izq() indice = expresion() corchete_der() )?
    {
      if (t != null) { 
        try {
          // puede ser una variable simple o un vector
          
          s = tabla_simbolos.buscar_simbolo(t.image);
      	  
      	  if (s.ES_VARIABLE()) {
      	    reg.setTipo(s.getVariable());
      	    reg.setAsignable(true);
      	  }
      	  else if (s.ES_PARAMETRO()) {
      	    reg.setTipo(s.getVariable());
      	    if (s.ES_VALOR()) {
      	      reg.setParVal();
      	    }
      	    else if (s.ES_REFERENCIA()) {
      	      reg.setParRef();
      	      reg.setAsignable(true);
      	    }
          }
      	  else if (s.ES_ACCION()) {
      	    ErrorSemantico.deteccion("No se puede utilizar una acción dentro de una expresión", t);
      	    reg.setTipoDesc();
      	  }
      	  else if (s.ES_PROGRAMA()) {
      	    ErrorSemantico.deteccion("No se puede utilizar un programa dentro de una expresión", t);
      	    reg.setTipoDesc();
      	  }
      	  else {
      	    reg.setTipoDesc();
      	  }

      	  
          // Vectores
          if (s.ES_VECTOR()) {
            if (indice == null) {
              System.err.println("Vector completo: " + s.getNombre() + " " + s.getLongitud());
              
              // Vector completo
              reg.setVector(true);
              reg.setLongitud(s.getLongitud());

              System.err.println("Registro: " + reg.getTipo() + " " + reg.esVector() + " " + reg.getLongitud());
            }
            else {
              // Acceso a una componente del vector
              System.err.println("Acceso a componente de vector: " + s.getNombre() + " " + s.getLongitud() + " " + indice.getValorEnt());
              
              // Comprobar tipo
              if (!indice.esDesc() && !indice.esEnt()) {
                ErrorSemantico.deteccion("La expresión para acceder a una componente del vector debe ser entera", t);
              }
              else if (indice.esEnt()) {
                // Comprobar overflow/underflow
                if (indice.getValorEnt() < 0) {
                  Aviso.deteccion(new UnderflowException(), t);
                }
                else if (indice.getValorEnt() >= s.getLongitud() - 1) {
                  Aviso.deteccion(new OverflowException(), t);
                }
              }
            }
          }
          else if (indice != null) {
            ErrorSemantico.deteccion("El símbolo no es un vector", t);
          }
        }
        catch (SimboloNoEncontradoException e) {
          ErrorSemantico.deteccion(e, t);
          reg.setTipoDesc();
        }
      }
    }
  | t = <tCONSTENTERA>
    {
      reg = new RegistroExpr();
      reg.setTipoEnt();
      reg.setValorEnt(Integer.parseInt(t.image));
    }
  | t = <tCONSTCHAR>
    {
      reg = new RegistroExpr();
      reg.setTipoChar();
      reg.setValorChar(t.image.charAt(0));
    }
  | <tTRUE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(true);
    }
  | <tFALSE>
    {
      reg = new RegistroExpr();
      reg.setTipoBool();
      reg.setValorBool(false);
    }
  }
  catch (ParseException e) {
    ErrorSintactico.deteccion(e, "Se esperaba un factor");
  }
  {
     return reg;
  }
}
